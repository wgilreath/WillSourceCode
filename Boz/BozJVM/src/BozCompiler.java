/* Generated By:JavaCC: Do not edit this line. BozCompiler.java */
import com.williamgilreath.BoolContext;
import com.williamgilreath.Code;
import com.williamgilreath.ICompiler;
import com.williamgilreath.LabelVector;
import com.williamgilreath.Name;
import com.williamgilreath.OrderedMap;
import com.williamgilreath.OrderedVector;
import com.williamgilreath.Scope;
import com.williamgilreath.StringVector;

import java.io.FileInputStream;
import java.io.FileNotFoundException;


public final class BozCompiler implements ICompiler, BozCompilerConstants {
    //maximum literal string length
    public final static int    MAX_LIT_STRING_LEN = 1024;

    //maximum lexeme identifier length
    public final static int    MAX_ID_LEN = 256;

    //maximum number of initial glob parameters
    public final static int MAX_GLOB_INIT = 65536;

    //maximum parameters to a method--0...16, or 1...17
    public final static int    MAX_PARAMS = 17;

    //maximum parameter of scope depth--0..16
    public final static int    MAX_SCOPE  = 17;

    //default dummy variable param id for variable args
    public final static String VAR_ARG_ID = "_xarg";

    //unit class or program flag
    public static boolean unitClassFlag = false;

    public static String  unitPckg = null; //unit package namespace
    public static Name    unitName = null; //unit name <package + id>
    public static String  unitId   = null; //unit id name identifier

    public static String codeBody = null;  //unit code body
    public static String codeBlck = null;  //unit code block

    //list of super-classes
    public final static OrderedVector superList = new OrderedVector();

    //super-class attribute code
    public static String codeSuper = null;

    //list-set of variable declarations
    public final static Scope localVar  = Scope.getScope();

    //list of included types => import NAME
    public final static OrderedVector    typeList  = new OrderedVector();

    //map of alias => type
    public final static OrderedMap typeAlias = new OrderedMap();

    //map of name => alias
    public final static OrderedVector nameAlias = new OrderedVector();

    //list of error messages
    public final static StringVector     errorList = new StringVector();

    //do-statement depth counter semantic check
    public static int                    doCounter    = 0;

    //try do-block statement depth counter semantic check
    public static int                    tryDoCounter = 0;

    //list-set of traps in try statement
    public final static OrderedVector    trapList   = new OrderedVector();
    public       static int              tryCounter = 0;

    //map-table of unit instance methods
    public final static OrderedMap imthdMap  = new OrderedMap();

    //list-set of instance methods
    public final static OrderedVector    imthdList = new OrderedVector();

    //map-table of unit static methods
    public final static OrderedMap smthdMap  = new OrderedMap();

    //list-set of static methods
    public final static OrderedVector    smthdList = new OrderedVector();

    //list-set of unit instance attributes
    public final static OrderedVector    iattrMap  = new OrderedVector();

    //list-set of unit singular attributes
    public final static OrderedVector    sattrMap  = new OrderedVector();

    //static context flag - singular attribute or method
    public       static boolean          staticCtxFlag = false;

    //static expression flag - primary is static type alias
    public       static boolean          staticExpFlag = false;

    //static boolean context within do-loop
    public final static BoolContext doCtx  = new BoolContext();

    //static boolean context within local block of statements
    public final static BoolContext blkCtx = new BoolContext();

    //static boolean context within try-block of statements and methods
    public final static BoolContext tryCtx = new BoolContext();

    public static String  declareVar    = null;

    public static boolean isDeclareFlag = false;

    public final static LabelVector label = new LabelVector();

/*                                                                         */
    //Boz Host Programming Language Keywords Sorted
    public final static String[] HOST_KEYWORD = new String[]
    {
        "abstract", "as", "assert",
        "base", "bool", "boolean",
        "break", "byte", "case",
        "catch", "char", "checked",
        "const", "continue", "decimal",
        "default", "delegate", "double",
        "enum", "event", "explicit",
        "extends", "extern", "final",
        "finally","fixed", "float",
        "for", "foreach", "goto",
        "implements", "implicit", "import",
        "in", "instanceof", "int",
        "interface", "internal", "is",
        "lock", "long", "namespace",
        "native", "null", "object",
        "operator", "out", "override",
        "package", "params", "private",
        "protected", "public", "readonly",
        "ref", "return", "sbyte",
        "sealed", "short", "sizeof",
        "stackalloc", "static", "strictfp",
        "string", "struct", "super",
        "switch", "synchronized", "this",
        "throw", "throws", "transient",
        "typeof", "uint", "ulong",
        "unchecked", "unsafe", "ushort",
        "using", "virtual", "void",
        "volatile", "while"
    };

    public final static boolean isZeroLiteral(final String value)
    {
        final char[] chars = value.toCharArray();

        for(int i = 0; i < chars.length; i++)
        {
            switch (chars[i])
            {
              case '1':
              case '2':
              case '3':
              case '4':
              case '5':
              case '6':
              case '7':
              case '8':
              case '9':
                        return false;
              case 'd':
              case 'D':
              case 'e':
              case 'E':
                        return true;
            }//end switch
        }//end for

        return true;

    }//end isZeroLiteral

    public final static boolean checkRangeDbl(String dbl)
    {
        Double value = null;

        try
        {
            value = Double.valueOf(dbl).doubleValue();
        }
        catch(Exception ex)
        {
            return false;
        }//end try

        if (Double.isInfinite(value))
        {
            return false;
        }//end if

        //cannot be negative since - is an operator
        if (value == 0 && !isZeroLiteral(dbl))
        {
            return false;
        }//end if

        return true;

    }//end checkRangeDbl

    public final static boolean checkRangeLng(String lng)
    {
        Long value = null;
        try
        {
            if (lng.startsWith("0"))
            {
                value = Long.valueOf(lng, 16);
            }
            else
            {
                value = Long.valueOf(lng, 10);
            }//end if
        }
        catch(Exception ex)
        {
            return false;
        }//end try

        return true;

    }//end checkRangeLng

    //auxillary method to search table of host language keywords
    public final static boolean binarySearch(final String[] list, final String key)
    {
        int lo = -1, hi = list.length, at;

        while(hi - lo > 1)
        {
            at = (lo+hi) / 2;

            if(list[at].compareTo(key) > 0)
                hi = at;
            else
            if(list[at].compareTo(key) < 0)
                lo = at;
            else
            if(list[at].compareTo(key) == 0)
                return true;

        }//end while

        return false;

    }//end binarySearch

    //check within context if identifier is host language keyword
    public final static boolean isHostKeyword(final String id)
    {
        return binarySearch(HOST_KEYWORD, id);
    }//end isHostKeyword

    //check within context if statement is reachable in sequence
    public final static boolean checkCtx()
    {
       return blkCtx.flag() || tryCtx.flag() ;
    }//end checkCtx

    public final static void addUnitName(final Name name)
    {
        unitName = name;
        if(name.hasPrefix())
            unitPckg = name.prefix();
        unitId = name.suffix();
    }//end addUnitName

    public final static void addUnitCode(final String body)
    {
        codeBody = body;
    }//end addUnitCode

    public final static void addUnitCode(final String body,
                                         final String block)
    {
        codeBody = body;
        codeBlck = block;
    }//end addUnitCode

    /*-------------------- instance utility methods --------------------*/

    public final static boolean isVarArgIMethod(final String key)
    {
        if(imthdMap.has(key))
            return false;

        return imthdList.has(key);
    }//end isVarArgMethod

    public final static boolean hasIMethod(final String key, final int index)
    {
       boolean result = false;

       //method with more MAX_PARAMS never found
       if(index >= MAX_PARAMS) return false;

       if(imthdMap.has(key))
       {
            final Boolean[] table = (Boolean[]) imthdMap.get(key);

            if(table == null)
                result = false;

            result = table[index] != null;
       }//end if

       return result;
    }//end hasMethod

    public final static void addIMethod(final String key, final int index)
    {
        if(index >= MAX_PARAMS) return;

        Boolean[] table = (Boolean[]) imthdMap.get(key);

        if(table == null) table = new Boolean[MAX_PARAMS];

        table[index] = Boolean.TRUE;
        imthdMap.add(key, table);

        addIMethodList(key); //add to method list

    }//end addIMethod

    public final static void addIMethodList(final String key)
    {
        if(imthdList.has(key))
            return;

        imthdList.add(key);
    }//end addMethodList

    /*-------------------- singular utility methods --------------------*/

    public final static boolean isVarArgSMethod(final String key)
    {
        if(smthdMap.has(key))
            return false;

        return smthdList.has(key);
    }//end isVarArgSMethod

    public final static boolean hasSMethod(final String key, final int index)
    {
        boolean result = false;

        //method with more MAX_PARAMS never found
        if(index >= MAX_PARAMS) return false;

        if(smthdMap.has(key))
        {
            final Boolean[] table = (Boolean[]) smthdMap.get(key);

            if(table == null)
                result = false;
            result = table[index] != null;
        }//end if

       return result;
    }//end hasSMethod

    public final static void addSMethod(final String key, final int index)
    {
        if(index >= MAX_PARAMS) return;

        Boolean[] table = (Boolean[]) smthdMap.get(key);

        if(table == null) table = new Boolean[MAX_PARAMS];

        table[index] = Boolean.TRUE;
        smthdMap.add(key, table);

        addSMethodList(key); //add to method list

    }//end addSMethod

    public final static void addSMethodList(final String key)
    {
        if(smthdList.has(key)) return;

        smthdList.add(key);
    }//end addSMethodList

    public final static void addName(final Name name)
    {
        if(name.hasPrefix())
        {
            unitPckg = name.prefix();
        }//end if

        unitId = name.suffix();
    }//end addName

    public final static void addType(final Name name)
    {
        if(name.size() > 1)
        {
            typeList.add(name);
        }//end if
    }//end addType

    public final static void addAlias(final String alias, final Name name)
    {
        typeAlias.add(alias,name);
        nameAlias.add(name);
    }//end addAlias

    public final static boolean hasName(final Name name)
    {
        return nameAlias.has(name);
    }//end hasName

    public final static boolean hasAlias(final String alias)
    {
        return typeAlias.has(alias);
    }//end hasAlias

    public final static Name getAlias(final String alias)
    {
        return (Name) typeAlias.get(alias);
    }//end getAlias

    public final static void error(final String text)
    {
        errorList.add(text);
    }//end error

    public static int counterIntVar = 0;

    public final static String uniqueIntVar()
    {
        return "_int"+Integer.toString(counterIntVar++);
    }//end uniqueIntVar

    //Code to create instance attribute method:
    //    _iget(String): IHandle  for 0...n-1 of N attributes
    public final static String emitIAttr()
    {
        Code code = new Code();

        code.eol(2);

        code.cat("public final IHandle _iget(final String attr){");
        code.eol();

        String attr = null;

        if(iattrMap.size() > 0)
        {
            attr = (String) iattrMap.get(0);

            code.add("    if(attr.equals(\u005c"");
            code.add(attr.substring(0,attr.length()-1)+"\u005c"))");
            code.cat("        return "+attr+";");

            for(int x=1;x<iattrMap.size();x++)
            {
                attr = (String) iattrMap.get(x);

                //check if attr in superList, do not synthesize
                //code for super-class attribute ?? 7-28-2008   

                code.cat("    else ");
                code.add("    if(attr.equals(\u005c"");
                code.add(attr.substring(0,attr.length()-1));
                code.add("\u005c"))");
                code.cat("        return "+attr+";");

            }//end for

            code.cat("    else ");

        }//end if

        code.spc(8);

        code.add("throw new BozTrap(\u005c"RuntimeTrap\u005c",\u005c"Attribute: \u005c"");
        code.add("+attr.toString()+");
        code.cat(" \u005c" not found in class.\u005c" ); ");

        code.eol();

        code.cat("}");

        code.eol();

        return code.toString();

    }//end emitIAttr

    //Code to create static attribute method:
    //    _sget(String): IHandle  for 0...n-1 of N attributes 
    public final static String emitSAttr()
    {
        Code code = new Code();

        code.eol(2);

        code.cat("public final static IHandle _sget(final String attr){");
        code.eol();

        String attr = null;

        if(sattrMap.size() > 0)
        {
            attr = (String) sattrMap.get(0);

            code.add("    if(attr.equals(\u005c"");
            code.add(attr.substring(0,attr.length()-1));
            code.cat("\u005c"))");
            code.cat("        return "+attr+";");

            for(int x=1;x<sattrMap.size();x++)
            {
                attr = (String) sattrMap.get(x);

                //check if attr in superList, do not synthesize
                //code for super-class attribute ?? 7-28-2008   

                code.cat("    else ");
                code.cat("    if(attr.equals(\u005c"");
                code.add(attr.substring(0,attr.length()-1));
                code.add("\u005c"))");
                code.cat("        return "+attr+";");

            }//end for

            code.cat("    else ");

        }//end if

        code.spc(8);
        code.add("throw new BozTrap(\u005c"RuntimeTrap\u005c",\u005c"Attribute:  \u005c"");
        code.add("+attr.toString()+");
        code.cat("\u005c" not found in class.\u005c"); ");

        code.eol();
        code.cat("}");

        code.eol(2);

        return code.toString();

    }//end emitSAttr

    public final static String emitICall()
    {
        Code          code        = new Code();

        code.eol(3);

        //code for _idx -- index of super-classes used by _icall method
        code.eol();
        code.cat("public final IHandle[] _idx;");

        //code for _icall -- standard boilerplate
        code.eol(2);
        code.add(emitIMethodCall() );
        code.eol(2);

        //code for _iexec
        code.add( emitIMethodExec() );
        code.eol(2);

        return code.toString();

    }//end emitICall

    public final static String emitConstruct()
    {
        Code code = new Code();

        code.eol(2);

        code.add("public ");
        code.add(unitId.toString());
        code.cat("(){");

        code.eol();
        code.cat("        this._my  = this;");
        code.eol();
        code.cat("        this._idx = new IHandle[] ");
        code.cat("        {                         ");
        code.cat("            this._my  ");

        //add any super-classes
        for (int x = 0; x < superList.size(); x++)
        {
            code.add(",");
            code.eol();
            code.add("        ");
            code.add((String) superList.get(x));
            code.add(" ");
        }//end for

        code.cat("        };");

        code.cat("}");
        code.eol(2);

        return code.toString();

    }//end emitConstruct

    public final static String emitHandle()
    {
        Code code = new Code();

        code.cat("public final IHandle _my;");

        code.eol(2);
        code.cat("private       IHandle _ival = RT.nil();");
        code.eol();
        code.cat("private BozTrap _myTrap = null;");

        code.eol();
        code.cat("public final IHandle _get(){  return this._ival; } ");
        code.eol();
        code.add("public final void    _set(final IHandle hdl)");
        code.cat("{ this._ival = hdl._get(); } ");
        code.eol();
        code.cat("public final boolean  _isNumber(){ return false; } ");
        code.cat("public final boolean  _isString(){ return false; } ");
        code.cat("public final boolean  _isStream(){ return false; } ");
        code.cat("public final boolean  _isBool(){ return false; }   ");
        code.cat("public final boolean  _isGlob(){ return false; }   ");
        code.cat("public final boolean  _isObject(){ return false; } ");
        code.cat("public final boolean  _isInstance(){ return true; }");

        code.eol(2);

        code.add("public final int      _size()");
        code.add("{  throw new BozTrap(\u005c"NonGlobSize\u005c",");
        code.cat("\u005c"Size non-existent for non-glob.\u005c"); } ");

        code.add("public final IHandle  _at(final IHandle   hdl)");
        code.add("{ throw new BozTrap(\u005c"");
        code.cat("NonGlobIndexAccess\u005c",\u005c"Access non-glob with index.\u005c"); }");

        code.add("public final IHandle  _by(final IHandle[] hdl)");
        code.add("{ throw new BozTrap(\u005c"");
        code.add("NonGlobAssociativeAccess\u005c",");
        code.cat("\u005c"Access non-glob with key.\u005c"); }");

        code.add("public final IHandle  _of(final int       pos)");
        code.add("{ throw new BozTrap(\u005c"");
        code.add("NonGlobPositionAccess\u005c",");
        code.cat("\u005c"Access non-glob with native int index.\u005c"); }");

        code.eol(2);

        code.cat("public final BozNumber _val(){");
        code.cat("   this._icall(\u005c"val\u005c", RT.box()); ");
        code.cat("   return this._get()._val();  ");
        code.cat("}");
            code.eol();

            code.cat("public final BozString _str(){");
        code.cat("   this._icall(\u005c"str\u005c", RT.box()); ");
        code.cat("   return this._get()._str();  ");
            code.cat("}");
        code.eol();

            code.add("public final IHandle   _import(IHandle hdl)");
        code.add("{ throw new BozTrap(\u005c"");
        code.cat("NonStreamTrap\u005c",\u005c"Import on non-stream\u005c"); }");


            code.add("public final IHandle   _export(IHandle hdl)");
        code.add("{ throw new BozTrap(\u005c"");
        code.cat("NonStreamTrap\u005c",\u005c"Export on non-stream\u005c"); }");


            code.add("public final String  toString()");
        code.add("{ return this._str().toString();");
        code.cat(" }                                       ");

            code.add("public final Double  toNumber()");
        code.add("{ return this._val().toNumber();");
        code.cat(" }                                       ");

            code.add("public final boolean toBool(){ throw new BozTrap(\u005c"");
        code.cat("NonBoolTrap\u005c",\u005c"Non Boolean value on instance.\u005c"); } ");

        return code.toString();
    }//end emitHandle

    public final static String emitHead()
    {
        Code code = new Code();

        code.eol(2);

        code.add("public final class ");
        code.add(unitId.toString());
        code.cat(" implements IHandle { ");
        code.eol(2);

        return code.toString();
    }//end emitHead

    public final static String emitIMethodExec()
    {
        final Code code = new Code();

        code.add("public final boolean _iexec");
        code.cat("(final String mthd, IHandle[] args){");
        code.eol();
        code.cat("    boolean result = true;");
        code.eol(2);

        for(int x=0;x<imthdList.size();x++)
        {
            final String mthd = (String) imthdList.get(x);

            code.cat("    if(mthd.equals(\u005c""+mthd+"\u005c"))");

            if(isVarArgIMethod(mthd))
            {
                code.cat("        this."+mthd+"_(args);");
            }
            else
            {
                code.add( emitIMethodFixArgs(mthd) );
            }//end if

            code.cat("    else");

        }//end for

        code.cat("        result =  false;");
        code.eol();
        code.cat("    return result;");
        code.cat("}");

        return code.toString();
    }//end emitIMethodExec

    public final static String emitIMethodFixArgs(final String mthd)
    {
        final Code code = new Code();

        code.cat("        switch(args.length){");

        final Boolean[] argv = (Boolean[]) imthdMap.get(mthd);

        for(int x=0;x<argv.length;x++)
        {
            if(argv[x] != null)
            {
                code.add("            case "+x+" : "+mthd+"_(");
                for(int y=0;y<x;y++)
                {
                    code.add("args["+y+"]");
                    if(y < x-1) code.add(", ");
                }//end for

               code.cat("); break;");

            }//end if

        }//end for

        code.cat("            default : break; ");
        code.eol();
        code.cat("        }");

        return code.toString();
    }//end emitIMethodFixArgs

    public final static String emitIMethodCall()
    {
        final Code code = new Code();

        code.add("public final IHandle _icall(final String mthd, ");
        code.cat("IHandle[] args)                                ");
        code.cat("{                                              ");
        code.cat("  this._ival = RT.obj(RT.nil());               ");
        code.eol();
        code.cat("  for(int x=0;x<_idx.length;x++){              ");
        code.cat("      if(_idx[x]._iexec(mthd,args)){           ");
        code.cat("           this._ival = _idx[x]._get();        ");
        code.eol();
        code.cat("           return this._ival;                  ");
        code.eol();
        code.cat("      }                                        ");
        code.eol();
        code.cat("  }                                            ");
        code.eol();
        code.add("    throw new BozTrap(\u005c"RuntimeTrap\u005c",\u005c"Method:");
        code.add("\u005c"+mthd+\u005c" of: \u005c"+args.length+\u005c" parameters not");
        code.cat(" found in class.\u005c"); ");
        code.eol();
        code.cat("}                                              ");
        code.eol();

        return code.toString();

    }//end emitIMethodCall

    public final static String emitSMethodExec()
    {
        final Code code = new Code();

        final String clsName = unitId; //get unit class name, XXX

        code.eol();
        code.cat("public static IHandle    _sval = null;");
        code.eol();
        code.add("public final static void _sret(final IHandle _rval){ ");
        code.add(clsName);
        code.add("._sval = _rval; ");
        code.cat("}");
        code.eol(2);

        code.add("public final static IHandle _scall(final String mthd, ");
        code.cat("final IHandle[] args){");
        code.eol();

        if(smthdList.size() > 0)
        {
            code.add("    ");
            code.add(clsName);
            code.cat("._sval = RT.obj(RT.nil());");
            code.eol();
        }//end if

        code.eol();

        for(int x=0;x<smthdList.size();x++)
        {
            final String mthd = (String) smthdList.get(x);

            if(x > 0) code.cat("    else");

            code.cat("    if(mthd.equals(\u005c""+mthd+"\u005c"))");

            if(isVarArgSMethod(mthd))
            {
                code.cat("        this."+mthd+"_(args);");
            }
            else
            {
                code.add( emitSMethodFixArgs(mthd) );
            }//end if

            //code.cat("    else");
            //code.cat("        throw new BozTrap(\"RuntimeTrap\",\"");
            //code.cat("Static method not found:  \"+mthd);");
            //code.eol();

        }//end for

        //code.eol();

        if(smthdList.size() > 0)
        {
            code.add("    else");
            code.eol();
            code.add("        throw new BozTrap(\u005c"RuntimeTrap\u005c",\u005c"");
            code.cat("Static method not found:  \u005c"+mthd);");

            code.eol();
            code.add("    return ");
            code.add(clsName);
            code.add("._sval;");
            code.eol();
        }
        else
        {
            code.eol();
            code.add("        throw new BozTrap(\u005c"RuntimeTrap\u005c",\u005c"");
            code.cat("Static method not found:  \u005c"+mthd);");
        }//end if


        code.eol();
        code.cat("}");

        return code.toString();
    }//end emitSMethodExec

    public final static String emitSMethodFixArgs(final String mthd)
    {
        final Code code = new Code();

        code.cat("        switch(args.length){");

        Object result = smthdMap.get(mthd);
        final Boolean[] argv = (Boolean[]) result;

        //final Boolean[] argv = (Boolean[]) smthdMap.get((Comparable) mthd);

        for(int x=0;x<argv.length;x++)
        {
            if(argv[x] != null)
            {
                code.add("            case "+x+" : "+mthd+"_(");
                for(int y=0;y<x;y++)
                {
                    code.add("args["+y+"]");
                    if(y < x-1) code.add(", ");
                }//end for

                code.cat("); break;");

            }//end if

        }//end for

        code.cat("            default : break; ");
        code.eol();
        code.cat("        }");

        return code.toString();

    }//end emitSMethodFixArgs

    public final static String emitNamespace()
    {
        Code          code        = new Code();

        code.eol(2);

        if(unitPckg != null)
        {
            code.cat("package "+unitPckg+"; ");
        }//end if

        code.eol(2);

        return code.toString();
    }//end emitNamespace

    public final static String emitInclude()
    {
        Code          code        = new Code();
        OrderedVector includeList = new OrderedVector();

        code.cat(emitNamespace());

        final String[] standardInclude = new String[]
        {
            "import org.bozlang.OrderedMap;",
            "import org.bozlang.BozBool;",
            "import org.bozlang.BozGlob;",
            "import org.bozlang.BozIO;",
            "import org.bozlang.BozNil;",
            "import org.bozlang.BozNumber;",
            "import org.bozlang.BozObject;",
            "import org.bozlang.BozString;",
            "import org.bozlang.BozTrap;",
            "import org.bozlang.IHandle;",
            "import org.bozlang.RT;",
            ""
        };

        //add standard includes to includeList
        for(int x=0;x<standardInclude.length;x++)
        {
            includeList.add(standardInclude[x]);
        }//end for

        //add type aliases to includeList
        for(int x=0;x<typeList.size();x++)
        {
            includeList.add("import "+((Name)typeList.get(x)).toString()+";");
        }//end for

        //add include list to code
        code.eol();
        for(int x=0;x<includeList.size(); x++)
        {
            code.cat((String) includeList.get(x));
        }//end for

        code.eol();

        return code.toString();
    }//end emitInclude

    public final static String emitUnit()
    {
        Code code = new Code();
        code.eol();

        if(unitClassFlag)
        {
            if(codeBody != null)
            {
                code.eol();
                code.cat(codeBody);
                code.eol(2);
            }//end if

            code.eol(2);
        }
        else
        {
            code.eol(2);

            if(codeBody != null)
            {
                code.eol();
                code.cat(codeBody);
                code.eol(2);
            }//end if

            code.eol(2);
            code.cat("private final void _lambda(){");
            code.eol();
            code.cat(codeBlck);
            code.eol();
            code.cat("}");
            code.eol(2);

            code.cat("public final static void main(final String[] args){");
            code.eol();

            code.add("    final ");
            code.add(unitName.toString());  //suffix for typename?? 7-28-2008
            code.add(" _it = new ");
            code.add(unitName.toString());
            code.add("(); ");
            code.eol(2);
            code.cat("    RT.init(args);        ");

            code.cat("    try {                 ");
            code.eol();
            code.cat("        _it._lambda();    ");
            code.eol();
            code.cat("    }catch(BozTrap _bt){  ");
            code.cat("        RT.kill(_bt);     ");
            code.cat("    }catch(Exception _ex){");
            code.cat("        RT.kill(_ex);     ");
            code.cat("    }catch(Error _er){    ");
            code.cat("        RT.kill(_er);     ");
            code.cat("    }                     ");
            code.eol();
            code.cat("    RT.halt();            ");

            code.eol();
            code.cat("}                         ");

        }//end if

        code.eol();
        return code.toString();
    }//end emitUnit

    public final static String emit()
    {
        Code code = new Code();

        code.eol(2);

        code.add(emitInclude());

        code.eol(2);

        code.cat(emitHead());
        code.eol(2);

        if(codeSuper != null)
        {
            code.cat(codeSuper); //emitSupers()??
            code.eol(2);
        }//end if

        code.cat(emitConstruct());
        code.eol(2);

        code.cat(emitHandle());

        code.eol(2);
        code.cat(emitUnit());
        code.eol(2);
        code.add(emitIAttr()); //add synthesized code for _iget
        code.eol(2);
        code.add(emitICall()); //add synthesized code for _idx, _icall, _iexec
        code.eol(4);
        code.add(emitSAttr());
        code.eol(4);
        code.add(emitSMethodExec());
        code.eol(2);
        code.cat("}");  //class footer
        code.eol(2);

        return code.toString();
    }//end emit

    public final static BozCompiler initialize(java.io.InputStream stream)
    {
        return new BozCompiler(stream);
    }//end initialize

    public final boolean compile()
    {
         try
         {
            BozCompiler.Start();
         }
         catch (ParseException e)
         {
            error(e.getMessage());
         }//end try

         return errorList.isEmpty();
    }//end compile

    public final String getCode()
    {
        return emit();
    }//end getCode

    public final Name getName()
    {
        return BozCompiler.unitName;
    }//end getName

    public final String getErrors()//String[] ??
    {
        return errorList.toString();
    }//end getErrors

    public final boolean isUnitClass()
    {
        return BozCompiler.unitClassFlag;
    }//end isUnitClass

    public final static void main(String args[])
    {
        ICompiler comp = null;

        if (args.length == 0)
        {
            System.out.println("Reading from standard input...");
            comp = BozCompiler.initialize(System.in);
        }
        else
        if (args.length == 1)
        {
            System.out.println("Reading from file: " + args[0] + ".");

            try
            {
                comp = initialize(new FileInputStream(args[0]));
            }
            catch (FileNotFoundException e)
            {
                System.err.println("File " + args[0] + " not found.");
                System.exit(1);
            }//end try
        }
        else
        {
            System.err.println("Usage is one of:");
            System.err.println("         java BozCompiler inputfile");
            System.exit(1);
        }//end if

        System.out.println();
        if(comp.compile())
        {
            System.out.println(comp.getCode());
        }
        else
        {
            System.out.print("Compiler Errors:  ");
            System.out.println(comp.getErrors());
            System.exit(1);
        }//end if

        System.exit(0);
    }

/**********************************************************
           The Boz Language Grammar
***********************************************************/

//START ::= UNIT
  static final public void Start() throws ParseException {
    String code = null;
    Unit();
    jj_consume_token(0);
  }

//UNIT ::= (CLASS)
  static final public void Unit() throws ParseException {
    Class();
  }

//CLASS ::= "class" NAME [SUPERS] ":" [BODY] [ ":" BLOCK ] "."
  static final public void Class() throws ParseException {
    String body   = null;
    Name   name   = null;
    String supers = null;
    Token  tok    = null;
    String block  = null;
    jj_consume_token(CLASS);
      unitClassFlag = true;
    name = Name();
      addUnitName(name);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LT:
      supers = Supers();
          codeSuper = supers;
      break;
    default:
      jj_la1[0] = jj_gen;
      ;
    }
    jj_consume_token(COLON);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case TILDE:
    case PLUS:
    case MINUS:
      body = Body();
      break;
    default:
      jj_la1[1] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COLON:
      tok = jj_consume_token(COLON);
          unitClassFlag = false;
          tryCtx.start();
      block = Block(tok.beginLine);
          tryCtx.close();
      break;
    default:
      jj_la1[2] = jj_gen;
      ;
    }
        if(unitClassFlag)
        {
            addUnitCode(body);
        }
        else
        {
            addUnitCode(body, block);
        }
    jj_consume_token(DOT);
  }

//SUPERS ::= ( "<" NAME "=" ID )+
  static final public String Supers() throws ParseException {
    String id   = null;
    Name   name = null;
    Code   code = new Code();

    OrderedVector types  = new OrderedVector();
    OrderedVector supers = new OrderedVector();
    Token         tok    = null;
    label_1:
    while (true) {
      tok = jj_consume_token(LT);
      name = Name();
        if(unitName.compareTo(name)==0)
        {
            error("#01 - Duplicate class name - class cannot inherit itself;"
                 +" class name '"+name.toString()
                 +"' in super-class list on line "+tok.beginLine
                 +" at position "+tok.beginColumn+".");
        }

        if(types.has(name))
        {
            error("#02 - Duplicate super-class name '"+name.toString()
                 +"' in super-class list on line"
                 +tok.beginLine+" at position "+tok.beginColumn+".");
        }
        else
        {
            types.add(name);
            addType(name);
        }
      tok = jj_consume_token(ASSIGN);
      id = Id();
        if(supers.has(id))
        {
            error("#03 - Duplicate super-class id '"+id
                 +"' alias in super-class list on line "
                 +tok.beginLine+" at position "+tok.beginColumn+".");
        }
        else
        {
            supers.add(id);
            iattrMap.add(id+"_");
            superList.add(id+"_");
        }
        code.add("private final IHandle ");
        code.add(id+"_ = new ");
        code.add(name.toString());
        code.add("();");
        code.eol();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        ;
        break;
      default:
        jj_la1[3] = jj_gen;
        break label_1;
      }
    }
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//BODY ::= ( IMETHOD | IATTRIBUTE | SATTRIBUTE | SMETHOD )+
  static final public String Body() throws ParseException {
    Code   code = new Code();
    String src  = null;
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BANG:
        src = IMethod();
      code.cat(src);
        break;
      case TILDE:
        src = IAttribute();
      code.cat(src);
        break;
      case MINUS:
        src = SAttribute();
      code.cat(src);
        break;
      case PLUS:
        src = SMethod();
      code.cat(src);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BANG:
      case TILDE:
      case PLUS:
      case MINUS:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
    }
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//IATTRIBUTE ::= "~" ID "=" (EXPR|GLOB) ";"
  static final public String IAttribute() throws ParseException {
    String id   = null;
    String expr = null;
    Code   code = new Code();
    Token  tok  = null;
    jj_consume_token(TILDE);
      code.add("public final IHandle ");
    tok = IdTok();
      code.add(tok.image+"_");
        if(iattrMap.has(tok.image+"_") || sattrMap.has(tok.image+"_"))
            error("#04 - Duplicate instance attribute '"+tok.image
                 +"' on line "+tok.beginLine+" at position "+tok.beginColumn
                 +" in attribute declaration.");
        else
            iattrMap.add(tok.image+"_");
    jj_consume_token(ASSIGN);
      code.add(" = ");
      code.add("RT.obj(");
    if (jj_2_1(3)) {
      expr = Expr();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        expr = Glob();
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      code.add(expr);
    jj_consume_token(SEMICOLON);
      code.cat(");");
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//SATTRIBUTE ::= "-" ID "=" (EXPR | GLOB) ";"
  static final public String SAttribute() throws ParseException {
    String id   = null;
    String expr = null;
    Code   code = new Code();
    Token  tok  = null;
    jj_consume_token(MINUS);
        staticCtxFlag = true;
        code.add("public final static IHandle ");
    tok = IdTok();
      code.add(tok.image+"_");
        if(iattrMap.has(tok.image+"_") || sattrMap.has(tok.image+"_"))
            error("#05 - Duplicate static attribute '"+tok.image+"' on line "
                 +tok.beginLine+" at position "+tok.beginColumn
                 +" in attribute declaration.");
        else
            sattrMap.add(tok.image+"_");
    jj_consume_token(ASSIGN);
      code.add(" = ");
      code.add("RT.obj(");
    if (jj_2_2(3)) {
      expr = Expr();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        expr = Glob();
        break;
      default:
        jj_la1[7] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      code.add(expr);
    jj_consume_token(SEMICOLON);
        code.cat(");");
        staticCtxFlag = false;
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//IMETHOD ::= "!" ID [ "@" ID | IDLIST ] ":" BLOCK "."
  static final public String IMethod() throws ParseException {
    boolean  fixedParamFlag = true;
    String   param          = null;

    Code     code  = new Code();
    String   key   = null;
    String[] args  = new String[0];
    String   block = null;
    Token    tok   = null;
    tok = jj_consume_token(BANG);
        tryCtx.start();
    key = Id();
        localVar.begin();
        localVar.add(key);
        //name mangle name with suffix underscore
        code.add("public final void "+key+"_(");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case AT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AT:
        jj_consume_token(AT);
          fixedParamFlag = false;
        param = Id();
            if(imthdList.has(key) || smthdList.has(key))
            {
                error("#06 - Duplicate variable parameter "
                     +"instance method '"+key+"' re-declared on line: "
                     +tok.beginLine+" at position "+tok.beginColumn
                     +" in method declaration.");
            }
            else
            {
                imthdList.add(key);
                if(localVar.has(param))
                    error("#07 - Duplicate identifier: "+param
                         +" parameter identifier already declared "
                         +"in method '"+key+"' on line: "
                         +tok.beginLine+" at position "
                         +tok.beginColumn+" in method declaration.");
                else
                    localVar.add(param);
                    code.add("IHandle[] "+VAR_ARG_ID);
            }
        break;
      case IDENTIFIER:
        args = IdList();
            fixedParamFlag = true;
            for(int x=0;x<args.length;x++)
                if(localVar.has(args[x]))
                    error("#07 - Duplicate identifier: "+args[x]
                         +" parameter identifier already declared "
                         +"in method '"+key+"' on line: "
                         +tok.beginLine+" at position "
                         +tok.beginColumn+" in method declaration.");
                else
                    localVar.add(args[x]);

            if(args.length >= MAX_PARAMS)
                error("#08 - Constraint for instance Method '"+key
                     +"' exceeds maximum number of "+(MAX_PARAMS-1)
                     +"-parameters with "+args.length+" on line: "
                     +tok.beginLine+" at position "+tok.beginColumn+".");
            else
            {
                for(int x=0;x<args.length-1;x++)
                    code.add("IHandle "+args[x]+",");
                code.add("IHandle "+args[args.length-1]);
            }
        break;
      default:
        jj_la1[8] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[9] = jj_gen;
      ;
    }
        if(fixedParamFlag)
        {
            if(hasIMethod(key,args.length) || hasSMethod(key,args.length))
                error("#09 - Duplicate instance method '"+key+"' with "
                     +args.length+"-parameters re-declared on line: "
                     +tok.beginLine+" at position "+tok.beginColumn
                     +" in method declaration.");
            else
                addIMethod(key,args.length);
        }
        else
        {
            imthdList.add(key);
        }//end if

        code.cat("){");
        code.eol();
        //code to convert IHandle[] to glob data structure
        if(!fixedParamFlag)
        {
            code.cat("IHandle "+param+" = RT.obj(RT.glob("+VAR_ARG_ID+"));");
        }//end if

    tok = jj_consume_token(COLON);
    block = Block(tok.beginLine);
      code.add(block);
    jj_consume_token(DOT);
      tryCtx.close();
        code.cat("}");
        localVar.close();
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//SMETHOD ::= "+" ID [ "@" ID | IDLIST ] ":" BLOCK "."
  static final public String SMethod() throws ParseException {
    boolean  fixedParamFlag = true;
    String   param          = null;

    Code     code  = new Code();
    String   key   = null;
    String[] args  = new String[0];
    String   block = null;
    Token    tok   = null;
    tok = jj_consume_token(PLUS);
      tryCtx.start();
      staticCtxFlag = true;
    key = Id();
        localVar.begin();
        localVar.add(key);

        //name mangle name with suffix underscore
        code.add("public final static void "+key+"_(");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IDENTIFIER:
    case AT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AT:
        jj_consume_token(AT);
          fixedParamFlag = false;
        param = Id();
            if(smthdList.has(key) || imthdList.has(key))
            {
                error("#10 - Duplicate variable parameter static method '"
                     +key+"' re-declared on line: "+tok.beginLine
                     +" at position "+tok.beginColumn
                     +" in method declaration.");
            }
            else
            {
                smthdList.add(key);
                if(localVar.has(param))
                    error("#11 - Duplicate identifier: "+param+" parameter "
                         +"identifier already declared in method '"
                         +key+"' on line: "+tok.beginLine+" at position "
                         +tok.beginColumn+" in method declaration.");
                else
                    localVar.add(param);
                code.add("IHandle[] "+VAR_ARG_ID);
            }
        break;
      case IDENTIFIER:
        args = IdList();
        fixedParamFlag = true;
        for(int x=0;x<args.length;x++)
            if(localVar.has(args[x]))
                error("#11 - Duplicate identifier: "+args[x]
                     +" parameter identifier already declared in method '"
                     +key+"' on line: "+tok.beginLine+" at position "
                     +tok.beginColumn+" in method declaration.");
            else
                localVar.add(args[x]);

        if(args.length >= MAX_PARAMS)
            error("#12 - Constraint for static Method '"+key
                 +"' exceeds maximum number of "+(MAX_PARAMS-1)
                 +"-parameters with "+args.length+" on line: "+tok.beginLine
                 +" at position "+tok.beginColumn+".");
        else
        {
            for(int x=0;x<args.length-1;x++)
                code.add("IHandle "+args[x]+",");
            code.add("IHandle "+args[args.length-1]);
        }
        break;
      default:
        jj_la1[10] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
        if(fixedParamFlag)
        {
            if(hasSMethod(key,args.length) || hasIMethod(key, args.length))
                error("#13 - Duplicate static method '"+key+"' with "
                     +args.length+"-parameters re-declared on line: "
                     +tok.beginLine+" at position "+tok.beginColumn
                     +" in method declaration.");
            else
                addSMethod(key,args.length);
        }
        else
        {
            smthdList.add(key);
        }//end if

        code.cat("){");
        code.eol();

        //code to convert IHandle[] to glob data structure
        if(!fixedParamFlag)
        {
            code.cat("IHandle "+param+" = RT.obj(RT.glob("+VAR_ARG_ID+"));");
        }//end if

    tok = jj_consume_token(COLON);
    block = Block(tok.beginLine);
      code.add(block);
    jj_consume_token(DOT);
      tryCtx.close();
        code.cat("}");
        localVar.close();
        staticCtxFlag = false;
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//STATEMENT ::= ( ASSIGN|STREAM|DECLARE|DO|JUMP|NOP|RETURN|SNAP|IF|TRY )
  static final public String Statement() throws ParseException {
    String stmt = null;
    Code   code = new Code();
    if (jj_2_3(4)) {
      stmt = Assign();
      code.add(stmt); code.eol();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case REM:
        stmt = Declare();
      code.add(stmt); code.eol();
        break;
      case DO:
        stmt = StatementDo();
      code.add(stmt); code.eol();
        break;
      case CUT:
      case END:
        stmt = StatementJump();
      code.add(stmt); code.eol();
        break;
      case SEMICOLON:
        stmt = StatementNop();
      code.add(stmt); code.eol();
        break;
      case DONE:
      case ASSIGN:
        stmt = StatementReturn();
      code.add(stmt); code.eol();
        break;
      case SNAP:
        stmt = StatementSnap();
      code.add(stmt); code.eol();
        break;
      case IF:
        stmt = StatementIf();
      code.add(stmt); code.eol();
        break;
      case TRY:
        stmt = StatementTry();
      code.add(stmt); code.eol();
        break;
      default:
        jj_la1[12] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//BLOCK ::= ( STATEMENT )+
  static final public String Block(final int line) throws ParseException {
    Code   code = new Code();
    String stmt = null;
      blkCtx.start();
        localVar.begin();
        if(localVar.getDepth() > MAX_SCOPE)
        error("#14 - Constraint for scope depth of block exceeds maximum of "
             +MAX_SCOPE+" on line: "+line+".");
    label_3:
    while (true) {
      stmt = Statement();
         code.add(stmt);
      if (jj_2_4(3)) {
        ;
      } else {
        break label_3;
      }
    }
      blkCtx.close();
      localVar.close();
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//DO ::= "do" [ID ("=" EXPR "," EXPR "," EXPR | ":" EXPR) | EXPR] ":" BLOCK "."
  static final public String StatementDo() throws ParseException {
    String block = null;
    Code   code  = new Code();

    String prefix = "";
    String ctrl   = "";
    String next   = "";
    String init   = "";

    String expr = null;

    String id  = null;
    String var = null;
    Token  tok = null;
    tok = jj_consume_token(DO);
        if(checkCtx())
        {
            error("#29 - Context of do statement on line "+tok.beginLine
                 +" at position "+tok.beginColumn
                 +" is unreachable with the block of statements.");
        }
      doCounter++;
      doCtx.start();
      doCtx.setTrue();
      label.start();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IT:
    case MY:
    case ARGS:
    case DIE:
    case ECHO:
    case EOL:
    case EXIT:
    case FALSE:
    case NEW:
    case NIL:
    case SCAN:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case AT:
    case DOLLAR:
    case PLUS:
    case MINUS:
    case REM:
    case ISGLOB:
    case SIZEOF:
      if (jj_2_5(2)) {
        tok = IdTok();
          id  = tok.image;
          if(localVar.has(id))
            error("#28 - Duplicate variable id '"+id+"' on line "
                 +tok.beginLine+" at position "+tok.beginColumn
                 +" in do statement already exists.");
          else
            localVar.add(id);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case ASSIGN:
              doCtx.setFalse();
          jj_consume_token(ASSIGN);
          expr = Expr();
                init = "IHandle "+id+" = RT.obj("+expr+")";
          jj_consume_token(COMMA);
          expr = Expr();
              ctrl = "RT.boolExpr("+expr+")";
          jj_consume_token(COMMA);
          expr = Expr();
              next = "RT.assign("+id+","+expr+")";
          break;
        case COLON:
              doCtx.setFalse();
          jj_consume_token(COLON);
              var = uniqueIntVar();
          expr = Expr();
              prefix = "int "+var+" = 0;";
              init = "IHandle "+id+" = RT.obj(RT.nil())";
              ctrl = var+" < ("+expr+")._size()";
              next = "RT.assign("+id+", ("+expr+")._of("+var+"++))";
          break;
        default:
          jj_la1[13] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IT:
        case MY:
        case ARGS:
        case DIE:
        case ECHO:
        case EOL:
        case EXIT:
        case FALSE:
        case NEW:
        case NIL:
        case SCAN:
        case TRUE:
        case INTEGER_LITERAL:
        case FLOATING_POINT_LITERAL:
        case CHARACTER_LITERAL:
        case STRING_LITERAL:
        case IDENTIFIER:
        case LPAREN:
        case BANG:
        case TILDE:
        case AT:
        case DOLLAR:
        case PLUS:
        case MINUS:
        case REM:
        case ISGLOB:
        case SIZEOF:
              doCtx.setFalse();
          expr = Expr();
              ctrl = "RT.boolExpr("+expr+")";
          break;
        default:
          jj_la1[14] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[15] = jj_gen;
      ;
    }
    tok = jj_consume_token(COLON);
    block = Block(tok.beginLine);
    jj_consume_token(DOT);
      doCounter--;
        if(doCtx.flag())
        {
            blkCtx.setTrue();
        }

        doCtx.close();
        if(id != null)
            localVar.drop(id);
        code.add(prefix);
        code.eol();

        code.add(label.getLabelLoop());

        code.add("for( ");

        code.add(init);
        code.add(";");
        code.add(ctrl);
        code.add(";");
        code.add(next);

        code.add("){");
        code.eol();

        code.add(block);
        code.add("}");
        code.eol();

        label.close();

        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//IF ::= "if" EXPR ":" BLOCK ( "ef" EXPR ":" BLOCK )* "else" BLOCK "."
  static final public String StatementIf() throws ParseException {
    String expr = null;
    String block= null;
    Code   code = new Code();
    Token  tok  = null;
    tok = jj_consume_token(IF);
        if(checkCtx())
        {
            error("#29 - Context of if statement on line "+tok.beginLine
                 +" at position "+tok.beginColumn
                 +" is unreachable with the block of statements.");
        }
      code.add("if( RT.boolExpr(");
    expr = Expr();
      code.add(expr);
    tok = jj_consume_token(COLON);
      code.add(") ){");
    block = Block(tok.beginLine);
      code.add(block);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EF:
        ;
        break;
      default:
        jj_la1[16] = jj_gen;
        break label_4;
      }
      jj_consume_token(EF);
            code.add("} else ");
            code.add("if( RT.boolExpr(");
      expr = Expr();
          code.add(expr);
      tok = jj_consume_token(COLON);
          code.add(") ){");
      block = Block(tok.beginLine);
          code.add(block);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ELSE:
      tok = jj_consume_token(ELSE);
          code.add("} else {");
      block = Block(tok.beginLine);
          code.add(block);
      break;
    default:
      jj_la1[17] = jj_gen;
      ;
    }
    jj_consume_token(DOT);
        code.add("}");
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//TRY ::= "try" BLOCK "on" BLOCK [ "do" BLOCK ] "."
  static final public String StatementTry() throws ParseException {
    Code   code  = new Code();
    String block = null;
    String lit   = null;
    Token  tok   = null;
    tok = jj_consume_token(TRY);
      tryCtx.start();
        if(checkCtx())
        {
            error("#29 - Context of try statement on line "+tok.beginLine
                 +" at position "+tok.beginColumn
                 +" is unreachable with the block of statements.");
        }
      code.cat("try {");
    block = Block(tok.beginLine);
      tryCtx.close();
      code.add(block);
      code.cat("} catch(BozTrap _bt){");
      code.cat("this._myTrap = _bt;  ");
    tok = jj_consume_token(ON);
    block = Block(tok.beginLine);
      code.add(block);
      code.add("}");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DO:
      tok = jj_consume_token(DO);
         tryDoCounter++;
         code.add("finally {");
      block = Block(tok.beginLine);
         code.add(block);
         code.add("}");
         tryDoCounter--;
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    jj_consume_token(DOT);
      tryCounter--;
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//JUMP ::= ("cut" | "end") [INTEGER] ";"
  static final public String StatementJump() throws ParseException {
    Code    code = new Code();
    Token   tok  = null;
    Token   semi = null;

    boolean cutFlag = false;
    boolean endFlag = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CUT:
      tok = jj_consume_token(CUT);
          cutFlag = true;
      break;
    case END:
      tok = jj_consume_token(END);
          endFlag = true;
          doCtx.setFalse();
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
      tok = jj_consume_token(INTEGER_LITERAL);
            final int depth = Integer.parseInt(tok.image, 10); //use intValue??

            if(depth >= MAX_SCOPE)
            {
                                error("#36 - Constraint for jump statement depth of "+tok.image
                                         +" on line "+tok.beginLine
                                         +" at position "+tok.beginColumn
                                         +" exceeds the maximum depth of "
                                         +MAX_SCOPE+".");

            }
            else
            if(depth >= label.size())
            {
                                error("#37 - Jump depth of "+tok.image
                                         +" on line "+tok.beginLine
                                         +" at position "+tok.beginColumn
                                         +" exceeds the current depth of "
                                         +label.size()+".");

            }
            else
            {
                if(cutFlag) label.cut(depth);
                if(endFlag) label.end(depth);
            }//end if

      break;
    default:
      jj_la1[20] = jj_gen;
      ;
    }
    semi = jj_consume_token(SEMICOLON);
        if(checkCtx())
        {
            error("#29 - Context of jump statement on line "+semi.beginLine
                 +" at position "+semi.beginColumn
                 +" is unreachable with the block of statements.");
        }
        if(doCounter == 0)
            error("#16 - Context of jump statement "+tok.image+" on line "
                 +tok.beginLine+" at position "+tok.beginColumn
                 +" is not within a do-statement.");

        if(tryDoCounter > 0)
            error("#17 - Context of jump statement "+tok.image+" on line "
                 +tok.beginLine+" at position "+tok.beginColumn
                 +" is within the do-block of a try statement.");
      if(cutFlag) blkCtx.setTrue();
        if(cutFlag)
        {
           code.add("continue ");
           code.add(label.getLabelCut());

        }
        else
        if(endFlag)
        {
           code.add("break ");
           code.add(label.getLabelEnd());

        }//end if

        code.add(";");
        code.eol();
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//NULL ::= ";"
  static final public String StatementNop() throws ParseException {
    Code code = new Code();
    Token semi = null;
    semi = jj_consume_token(SEMICOLON);
        if(checkCtx())
        {
            error("#29 - Context of nop statement on line "+semi.beginLine
                 +" at position "+semi.beginColumn
                 +" is unreachable with the block of statements.");
        }
        code.cat("RT.Nop();");
        code.eol();
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//SNAP ::= "snap" [ EXPR "," EXPR ] ";"
  static final public String StatementSnap() throws ParseException {
    String  trap = "";
    String  cntx = "";
    Code    code = new Code();
    Token   semi = null;
    boolean flag = true;
    jj_consume_token(SNAP);
      code.add("throw RT.snap( ");
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IT:
    case MY:
    case ARGS:
    case DIE:
    case ECHO:
    case EOL:
    case EXIT:
    case FALSE:
    case NEW:
    case NIL:
    case SCAN:
    case TRUE:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case BANG:
    case TILDE:
    case AT:
    case DOLLAR:
    case PLUS:
    case MINUS:
    case REM:
    case ISGLOB:
    case SIZEOF:
           flag = false;
      trap = Expr();
      jj_consume_token(COMMA);
      cntx = Expr();
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
        if(flag)
        {
            code.add("this._myTrap");
        }
        else
        {
            //code.add("RT.lit("+trap+")"); 
            code.add("RT.str("+trap+")");
            code.add(" , ");
            //code.add("RT.lit("+cntx+")"); 
            code.add("RT.str("+cntx+")");
        }
      code.add(" );");
    semi = jj_consume_token(SEMICOLON);
        if(checkCtx())
        {
            error("#29 - Context of snap statement on line "+semi.beginLine
                 +" at position "+semi.beginColumn
                 +" is unreachable with the block of statements.");
        }
      doCtx.setFalse();
      blkCtx.setTrue();
      tryCtx.setTrue();
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//RETURN ::=  ( "done" | "=" EXPR ) ";"
  static final public String StatementReturn() throws ParseException {
    String expr = null;
    Code   code = new Code();
    Token  tok  = null;
    Token  semi = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      tok = jj_consume_token(ASSIGN);
      expr = Expr();
            if(staticCtxFlag)
            {
                code.add(unitName.toString());
                code.add("._sret( "+expr+");");
            }
            else
                code.add("RT.assign( this, "+expr+" ); ");
      break;
    case DONE:
      tok = jj_consume_token(DONE);
            if(staticCtxFlag)
            {
                code.add(unitName.toString());
                code.add("._sret( RT.nil() );");
            }
            else
                code.add("RT.assign( this, RT.nil() ); ");
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    semi = jj_consume_token(SEMICOLON);
        if(checkCtx())
        {
            error("#29 - Context of return statement on line "+semi.beginLine
                     +" at position "+semi.beginColumn
                     +" is unreachable with the block of statements.");
        }
      doCtx.setFalse();
        if(tryDoCounter > 0)
            error("#18 - Context of return statement on line "+tok.beginLine
                 +" at position "+tok.beginColumn
                 +" is within the do-block of a try statement.");
      code.add("return;");
      blkCtx.setTrue();
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//DECLARE ::= "%" ID "=" ( EXPR | GLOB ) ";"
  static final public String Declare() throws ParseException {
    String id   = null;
    String expr = null;
    Code   code = new Code();
    Token  tok  = null;
    Token  semi = null;
    jj_consume_token(REM);
      code.add("IHandle ");
    tok = IdTok();
      code.add(tok.image);
        isDeclareFlag = true;
        declareVar    = tok.image;
        if(localVar.has(tok.image))
            error("#19 - Duplicate variable id '"+tok.image+"' on line "
                 +tok.beginLine+" at position "+tok.beginColumn
                 +" in declaration.");
        else
            localVar.add(tok.image);
    jj_consume_token(ASSIGN);
      code.add(" = ");
      code.add("RT.obj(");
    if (jj_2_6(3)) {
      expr = Expr();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        expr = Glob();
        break;
      default:
        jj_la1[23] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
      code.add(expr);
    semi = jj_consume_token(SEMICOLON);
        if(checkCtx())
        {
            error("#29 - Context of declaration on line "+semi.beginLine
                 +" at position "+semi.beginColumn
                 +" is unreachable with the block of statements.");
        }
        declareVar    = null;
        isDeclareFlag = false;
      code.add(");");
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//ASSIGN ::= POSTFIX [ "=" ( EXPR | GLOB ) ] ";"
  static final public String Assign() throws ParseException {
    String pfix = null;
    String expr = null;
    Code   code = new Code();
    Token  tok  = null;
    pfix = Postfix();
        code.add(pfix);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ASSIGN:
      tok = jj_consume_token(ASSIGN);
        if(checkCtx())
        {
            error("#29 - Context of assignment statement on line "
                 +tok.beginLine+" at position "+tok.beginColumn
                     +" is unreachable with the block of statements.");
        }
          code.prefix("RT.assign(");
      if (jj_2_7(3)) {
        expr = Expr();
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LT:
          expr = Glob();
          break;
        default:
          jj_la1[24] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
          code.suffix(","+expr+")");
      break;
    default:
      jj_la1[25] = jj_gen;
      ;
    }
    jj_consume_token(SEMICOLON);
      code.add(";");
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//GLOB ::= "<" [ GLOBIMAGE | GLOBRANGE ] ">"
  static final public String Glob() throws ParseException {
    Code    code = new Code();
    boolean flag = false;
    String  glob = "RT.Glob();";
    jj_consume_token(LT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case LBRACE:
    case LBRACKET:
      if (jj_2_8(4)) {
        glob = GlobImage();
            flag = true;
            code.add("RT.GlobImage");
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case LBRACE:
          glob = GlobRange();
            flag  = true;
            code.add("RT.GlobRange");
          break;
        default:
          jj_la1[26] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      break;
    default:
      jj_la1[27] = jj_gen;
      ;
    }
    jj_consume_token(GT);
         if(flag)
         {
             code.add("( new IHandle[]{ ");
             code.add(glob);
             code.add(" } );");
             //RT.GlobXXX(new IHandle[]{ <expr,expr...expr,expr> });
         }
         else
         {
             code.add("RT.Glob();");
         }
         code.eol();
         {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

 //end Glob

//GLOBIMAGE ::= "[" EXPR ("," EXPR)* "]"
  static final public String GlobImage() throws ParseException {
    Code   code  = new Code();
    int    count = 1;
    String expr  = null;
    Token  tok   = null;
    jj_consume_token(LBRACKET);
    expr = Expr();
                          code.add(expr);
    label_5:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[28] = jj_gen;
        break label_5;
      }
      tok = jj_consume_token(COMMA);
                            count++;
                            if(count > MAX_GLOB_INIT)
                                error("#38 - Constraint for glob declaration"
                                     +" exceeds maximum of "+(MAX_GLOB_INIT)
                                     +" initial values for a glob on line: "
                                     +tok.beginLine+" at position "
                                     +tok.beginColumn+".");
      expr = Expr();
                             code.add(",");
                             code.add(expr);
    }
    jj_consume_token(RBRACKET);
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

 //end GlobImage

//GLOBRANGE ::= "{" EXPR "=" EXPR ("," EXPR "=" EXPR )* "}"
  static final public String GlobRange() throws ParseException {
    Code       code    = new Code();
    int        count   = 1;
    String     expr    = null;
    OrderedVector globMap = new OrderedVector();
    Token      tok     = null;
    jj_consume_token(LBRACE);
    expr = Expr();
                        globMap.add(expr);
                        code.add(expr);
    jj_consume_token(ASSIGN);
    expr = Expr();
                        code.add(",");
                        code.add(expr);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_6;
      }
      tok = jj_consume_token(COMMA);
                                                count++;
                                                if(count > MAX_GLOB_INIT)
                                                        error("#38 - Constraint for glob declaration"
                                                                 +" exceeds maximum of "+(MAX_GLOB_INIT)
                                                                 +" initial values for a glob on line: "
                                                                 +tok.beginLine+" at position "
                                                                 +tok.beginColumn+".");
                                                code.add(",");
      expr = Expr();
                                                if(globMap.has(expr))
                                                        error("#24 - Duplicate glob image expression in "
                                                                 +"glob declaration on line "+tok.beginLine
                                                                 +" at position "+tok.beginColumn
                                                                 +" in attribute declaration.");
                                                globMap.add(expr);
                                                code.add(expr);
      jj_consume_token(ASSIGN);
      expr = Expr();
                                                code.add(",");
                                                code.add(expr);
    }
    jj_consume_token(RBRACE);
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

 //end GlobRange

//GLOBCALL ::= "@" EXPR | ":" EXPR | "?" EXPR | "::" EXPR | "?:" EXPR | "!!" EXPR
  static final public String GlobCall() throws ParseException {
   //String[0] => globcall function
   //String[1] => expr or exprlist
   Code   code = new Code();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case AT:
      jj_consume_token(AT);
      Expr();
      break;
    case COLON:
      jj_consume_token(COLON);
      Expr();
      break;
    case HOOK:
      jj_consume_token(HOOK);
      Expr();
      break;
    case ATRANGE:
      jj_consume_token(ATRANGE);
      Expr();
      break;
    case ATIMAGE:
      jj_consume_token(ATIMAGE);
      Expr();
      break;
    case ATCLEAR:
      jj_consume_token(ATCLEAR);
      Expr();
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//EXPR ::= LOGEXPR ( "||" LOGEXPR )*
  static final public String Expr() throws ParseException {
    String expr = null;
    Code   code = new Code();
    String oper = "RT.ior(";
    expr = LogExpr();
                               code.add(expr);
    label_7:
    while (true) {
      if (jj_2_9(2)) {
        ;
      } else {
        break label_7;
      }
      jj_consume_token(OR);
      expr = LogExpr();
                               code.concat(oper,","+expr+")");
    }
                               code.concat("RT.expr(",")");
                               {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//LOGEXPR ::= INCEXPR ( "&&" INCEXPR )*
  static final public String LogExpr() throws ParseException {
    String expr = null;
    Code   code = new Code();
    String oper = "RT.and(";
    expr = IncExpr();
                               code.add(expr);
    label_8:
    while (true) {
      if (jj_2_10(2)) {
        ;
      } else {
        break label_8;
      }
      jj_consume_token(AND);
      expr = IncExpr();
                               code.concat(oper,","+expr+")");
    }
                               {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//INCEXPR ::= XOREXPR ( "|" XOREXPR )*
  static final public String IncExpr() throws ParseException {
    String expr = null;
    Code   code = new Code();
    String oper = "RT.iorb(";
    expr = XorExpr();
                               code.add(expr);
    label_9:
    while (true) {
      if (jj_2_11(2)) {
        ;
      } else {
        break label_9;
      }
      jj_consume_token(BIT_OR);
      expr = XorExpr();
                               code.concat(oper,","+expr+")");
    }
                               {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//XOREXPR ::= ANDEXPR ( "^" ANDEXPR )*
  static final public String XorExpr() throws ParseException {
    String expr = null;
    Code   code = new Code();
    String oper = "RT.xor(";
    expr = AndExpr();
                               code.add(expr);
    label_10:
    while (true) {
      if (jj_2_12(2)) {
        ;
      } else {
        break label_10;
      }
      jj_consume_token(XOR);
      expr = AndExpr();
                               code.concat(oper,","+expr+")");
    }
                               {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//ANDEXPR ::= EQUEXPR ( "&" EQUEXPR )*
  static final public String AndExpr() throws ParseException {
    String expr = null;
    Code   code = new Code();
    String oper = "RT.andb(";
    expr = EquExpr();
                               code.add(expr);
    label_11:
    while (true) {
      if (jj_2_13(2)) {
        ;
      } else {
        break label_11;
      }
      jj_consume_token(BIT_AND);
      expr = EquExpr();
                               code.concat(oper,","+expr+")");
    }
                               {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//EQUEXPR ::= RELEXPR ( ( "==" | "!=" ) RELEXPR )*
  static final public String EquExpr() throws ParseException {
    String expr = null;
    Code   code = new Code();
    String oper = "";
    expr = RelExpr();
                               code.add(expr);
    label_12:
    while (true) {
      if (jj_2_14(2)) {
        ;
      } else {
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EQ:
        jj_consume_token(EQ);
                               oper = "RT.eq(";
        break;
      case NE:
        jj_consume_token(NE);
                               oper = "RT.ne(";
        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      expr = RelExpr();
                               code.concat(oper,","+expr+")");
    }
                               {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//RELEXPR ::= SHIFTEXPR ( ( "<" | ">" | "<=" | ">=" ) SHIFTEXPR )*
  static final public String RelExpr() throws ParseException {
    String expr = null;
    Code   code = new Code();
    String oper = "";
    expr = ShiftExpr();
                               code.add(expr);
    label_13:
    while (true) {
      if (jj_2_15(2)) {
        ;
      } else {
        break label_13;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LT:
        jj_consume_token(LT);
                               oper = "RT.lt(";
        break;
      case GT:
        jj_consume_token(GT);
                               oper = "RT.gt(";
        break;
      case LE:
        jj_consume_token(LE);
                               oper = "RT.le(";
        break;
      case GE:
        jj_consume_token(GE);
                               oper = "RT.ge(";
        break;
      default:
        jj_la1[32] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      expr = ShiftExpr();
                               code.concat(oper,","+expr+")");
    }
                               {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//SHIFTEXPR ::= ADDEXPR ( ( "<<" | ">>" ) ADDEXPR )*
  static final public String ShiftExpr() throws ParseException {
    String expr = null;
    Code   code = new Code();
    String oper = "";
    expr = AddExpr();
                               code.add(expr);
    label_14:
    while (true) {
      if (jj_2_16(2)) {
        ;
      } else {
        break label_14;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case LSHIFT:
        jj_consume_token(LSHIFT);
                               oper = "RT.lsh(";
        break;
      case RSHIFT:
        jj_consume_token(RSHIFT);
                               oper = "RT.rsh(";
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      expr = AddExpr();
                               code.concat(oper,","+expr+")");
    }
                               {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//ADDEXPR ::= MULEXPR ( ( "+" | "-" ) MULEXPR )*
  static final public String AddExpr() throws ParseException {
    String expr = null;
    Code   code = new Code();
    String oper = "";
    expr = MulExpr();
                              code.add(expr);
    label_15:
    while (true) {
      if (jj_2_17(2)) {
        ;
      } else {
        break label_15;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case PLUS:
        jj_consume_token(PLUS);
                              oper = "RT.add(";
        break;
      case MINUS:
        jj_consume_token(MINUS);
                              oper = "RT.sub(";
        break;
      default:
        jj_la1[34] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      expr = MulExpr();
                              code.concat(oper,","+expr+")");
    }
                              {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//MULEXPR ::= UNARYEXPR ( ( "*" | "%" | "/" | "**" ) UNARYEXPR )*
  static final public String MulExpr() throws ParseException {
    String expr = null;
    Code   code = new Code();
    String oper = "";
    expr = UnaryExpr();
      code.add(expr);
    label_16:
    while (true) {
      if (jj_2_18(2)) {
        ;
      } else {
        break label_16;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STAR:
        jj_consume_token(STAR);
              oper = "RT.mul(";
        break;
      case REM:
        jj_consume_token(REM);
              oper = "RT.mod(";
        break;
      case SLASH:
        jj_consume_token(SLASH);
              oper = "RT.div(";
        break;
      case POW:
        jj_consume_token(POW);
              oper = "RT.pow(";
        break;
      default:
        jj_la1[35] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      expr = UnaryExpr();
          code.concat(oper,","+expr+")");
    }
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//UNARYEXPR ::= [ "!" | "~" | "+" | "-" | "$" | "%" | "%%" | "??" ] POSTFIX
  static final public String UnaryExpr() throws ParseException {
    String prefix   = null;
    String suffix   = null;
    String postfix  = null;
    Code   code     = new Code();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case BANG:
    case TILDE:
    case DOLLAR:
    case PLUS:
    case MINUS:
    case REM:
    case ISGLOB:
    case SIZEOF:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BANG:
        jj_consume_token(BANG);
           prefix = "RT.not(";  suffix = ")";
        break;
      case TILDE:
        jj_consume_token(TILDE);
           prefix = "RT.comp("; suffix = ")";
        break;
      case PLUS:
        jj_consume_token(PLUS);
           prefix = "RT.pos(";  suffix = ")";
        break;
      case MINUS:
        jj_consume_token(MINUS);
           prefix = "RT.neg(";  suffix = ")";
        break;
      case DOLLAR:
        jj_consume_token(DOLLAR);
           prefix = "RT.str(";  suffix = ")";
        break;
      case REM:
        jj_consume_token(REM);
           prefix = "RT.val(";  suffix = ")";
        break;
      case SIZEOF:
        jj_consume_token(SIZEOF);
           prefix = "RT.SizeOf("; suffix = ")";
        break;
      case ISGLOB:
        jj_consume_token(ISGLOB);
           prefix = "RT.IsGlob("; suffix = ")";
        break;
      default:
        jj_la1[36] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
    postfix = Postfix();
      code.add(postfix);
        if(prefix != null) code.concat(prefix,suffix);
      {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//POSTFIX ::= ( PREDEFFUN | PRIMARY 
//            ( ATTRIBUTECALL | GLOBCALL | METHODCALL )* 
//            [ "++" | "--" ] )
  static final public String Postfix() throws ParseException {
    Code   code    = new Code();
    String primary = null;
    String call    = null;
      staticExpFlag = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ARGS:
    case DIE:
    case ECHO:
    case EOL:
    case EXIT:
    case FALSE:
    case NEW:
    case SCAN:
    case TRUE:
      call = PredefFunc();
          {if (true) return call;}
      break;
    case IT:
    case MY:
    case NIL:
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
    case IDENTIFIER:
    case LPAREN:
    case AT:
      primary = Primary();
          code.add(primary);
      label_17:
      while (true) {
        if (jj_2_19(2)) {
          ;
        } else {
          break label_17;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TIC:
          call = AttributeCall();
                code.suffix(call);
          break;
        case COLON:
        case HOOK:
        case AT:
        case ATRANGE:
        case ATIMAGE:
        case ATCLEAR:
          call = GlobCall();
                code.suffix(call);
          call = MethodCall();
                code.suffix(call);
          break;
        default:
          jj_la1[38] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
      if (jj_2_20(2)) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INC:
          jj_consume_token(INC);
                  code.concat("RT.inc(",")");
          break;
        case DEC:
          jj_consume_token(DEC);
                  code.concat("RT.dec(",")");
          break;
        default:
          jj_la1[39] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      } else {
        ;
      }
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//PREDEFFUNC ::= ( FUNCARGS | FUNCDIE | FUNCECHO | FUNCEOL | FUNCEXIT | FUNCFALSE
//               | FUNCNEW | FUNCSCAN | FUNCTRUE )
  static final public String PredefFunc() throws ParseException {
    String func = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case ARGS:
      func = FuncArgs();
      break;
    case DIE:
      func = FuncDie();
      break;
    case ECHO:
      func = FuncEcho();
      break;
    case EOL:
      func = FuncEol();
      break;
    case EXIT:
      func = FuncExit();
      break;
    case FALSE:
      func = FuncFalse();
      break;
    case NEW:
      func = FuncNew();
      break;
    case SCAN:
      func = FuncScan();
      break;
    case TRUE:
      func = FuncTrue();
      break;
    default:
      jj_la1[41] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
      {if (true) return func;}
    throw new Error("Missing return statement in function");
  }

//FUNCARGS ::= "args"
  static final public String FuncArgs() throws ParseException {
    jj_consume_token(ARGS);
      {if (true) return "RT.args()";}
    throw new Error("Missing return statement in function");
  }

//FUNCCATCH ::= "catch"
  static final public String FuncCatch() throws ParseException {
    jj_consume_token(CATCH);
      {if (true) return "RT.Catch(this._myTrap)";}
    throw new Error("Missing return statement in function");
  }

//FUNCCAUSE ::= "cause"
  static final public String FuncCause() throws ParseException {
    jj_consume_token(CAUSE);
      {if (true) return "RT.Cause(this._myTrap)";}
    throw new Error("Missing return statement in function");
  }

//FUNCDIE ::= "die" ":" EXPR
  static final public String FuncDie() throws ParseException {
    String expr = null;
    jj_consume_token(DIE);
    jj_consume_token(COLON);
    expr = Expr();
      {if (true) return "RT.die("+expr+")";}
    throw new Error("Missing return statement in function");
  }

//FUNCECHO ::= "echo" [ ":" EXPRLIST ]
  static final public String FuncEcho() throws ParseException {
    Code   code = new Code();
    String list = "";
    jj_consume_token(ECHO);
    if (jj_2_21(2)) {
      jj_consume_token(COLON);
      list = ExprList();
    } else {
      ;
    }
        code.add("RT.Echo(");
        code.add(" RT.box(");
        code.add(list);
        code.add(") )");
        code.eol();
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//FUNCEOL ::= "eol"
  static final public String FuncEol() throws ParseException {
    jj_consume_token(EOL);
      {if (true) return "RT.Eol()";}
    throw new Error("Missing return statement in function");
  }

//FUNCEXIT ::= "exit" ":" EXPR
  static final public String FuncExit() throws ParseException {
    String expr = null;
    jj_consume_token(EXIT);
    jj_consume_token(COLON);
    expr = Expr();
      doCtx.setFalse();
      blkCtx.setTrue();
      {if (true) return "RT.exit("+expr+")";}
    throw new Error("Missing return statement in function");
  }

//FUNCFALSE ::= "false"
  static final public String FuncFalse() throws ParseException {
    jj_consume_token(FALSE);
      {if (true) return "RT.False()";}
    throw new Error("Missing return statement in function");
  }

//FUNCNEW ::= "new" ":" ( NAME "=" ID | ID )
  static final public String FuncNew() throws ParseException {
    Code   code = new Code();
    Name   name = null;
    String id   = null;
    Token  tok  = null;
    jj_consume_token(NEW);
      code.add("new ");
    tok = jj_consume_token(COLON);
    if (jj_2_22(2)) {
      name = Name();
            if(unitName.compareTo(name)==0)
            {
                error("#26 - Illegal type alias for class; "
                     +"use 'my' for instance class reference on line "
                     +tok.beginLine+" at position "+tok.beginColumn+".");
            }
            else
                addType(name);
      jj_consume_token(ASSIGN);
      tok = IdTok();
            id = tok.image;

            if(hasName(name))
                error("#27 - Duplicate namespace '"+name
                     +"' already has name alias; namespace is repeated; "
                     +"at line: "+tok.beginLine+" position: "
                     +tok.beginColumn+" to line: "+tok.endLine
                     +" position: "+tok.endColumn+".");

                    if(hasAlias(id))
                        error("#20 - Duplicate type alias '"+id
                             +"' is repeated; at line: "+tok.beginLine
                             +" position: "+tok.beginColumn+" to line: "
                             +tok.endLine+" position: "+tok.endColumn+".");
                    else
                        addAlias(id,name);

            code.add(getAlias(id).toString());
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case IDENTIFIER:
        tok = IdTok();
            id = tok.image;
            if(!hasAlias(id))
                error("#21 - Unknown type alias '"+id
                     +"' is undeclared; at line: "+tok.beginLine
                     +" position: "+tok.beginColumn+" to line: "
                     +tok.endLine+" position: "+tok.endColumn+".");
            else
                code.add(getAlias(id).toString());
        break;
      default:
        jj_la1[42] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
        code.add("()");
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//FUNCSCAN ::= "scan" [ ":" EXPR ]
  static final public String FuncScan() throws ParseException {
    Code   code = new Code();
    String expr = "";
    jj_consume_token(SCAN);
    if (jj_2_23(2)) {
      jj_consume_token(COLON);
      expr = Expr();
    } else {
      ;
    }
        code.add("RT.Scan(");
        code.add(" RT.lit(");
        code.add(expr);
        code.add(") )");
        code.eol();
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//FUNCTRUE ::= "true"
  static final public String FuncTrue() throws ParseException {
    jj_consume_token(TRUE);
      {if (true) return "RT.True()";}
    throw new Error("Missing return statement in function");
  }

//ATTRIBUTECALL ::= "`" ID
  static final public String AttributeCall() throws ParseException {
    String id   = null;
    Code   code = new Code();
    jj_consume_token(TIC);
        if(staticExpFlag)
        code.add("._sget(");
        else
        code.add("._iget(");
    id = Id();
        code.add("\u005c""+id+"\u005c")");
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//METHODCALL ::= "!" ID [ ":" EXPRLIST ]
  static final public String MethodCall() throws ParseException {
    String expr = null;
    String id   = null;
    Code   code = new Code();
    jj_consume_token(BANG);
    id = Id();
    if(staticExpFlag)
        code.add("._scall");
    else
        code.add("._icall");

    code.add("(\u005c""+id+"\u005c",");
    code.add("RT.box(");
    if (jj_2_24(2)) {
      jj_consume_token(COLON);
      expr = ExprList();
            code.add(expr);
    } else {
      ;
    }
    code.add("))");
    {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//PRIMARY ::= ( ID| "@" NAME "=" ID|"it"|"my"|"nil"|LIT|"(" EXPR ")" )
  static final public String Primary() throws ParseException {
    String expr   = null;
    Token  tok    = null;
    Name   name   = null;
    if (jj_2_25(3)) {
      tok = IdTok();
            if(isDeclareFlag)
            {
                if(declareVar.equals(tok.image))
                {
                    error("#35 - Context of variable "+tok.image
                         +" declaration on line "+tok.beginLine
                         +" at position "+tok.beginColumn
                         +" is an uninitialized self-reference.");
                }
            }

            if(localVar.has(tok.image))
            {
                {if (true) return tok.image;}
            }
            else if(typeAlias.has(tok.image))
            {
                staticExpFlag = true;
                {if (true) return getAlias(tok.image).toString();}
            }
            else
            {
                error("#22 - Unknown identifier '"+tok.image+"' on line "
                     +tok.beginLine+" at position "+tok.beginColumn
                     +" is undeclared as type alias or variable.");
                {if (true) return tok.image;}
            }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AT:
        tok = jj_consume_token(AT);
        name = Name();
            if(unitName.compareTo(name)==0)
            {
                error("#25 - Illegal type alias for class; use 'it' "
                     +"for static class reference on line "+tok.beginLine
                     +" at position "+tok.beginColumn+".");
            }
        jj_consume_token(ASSIGN);
        tok = IdTok();
            staticExpFlag = true;
            if(hasName(name))
                error("#27 - Duplicate namespace '"+name
                     +"' already has name "
                     +"alias; namespace is repeated; at line: "
                     +tok.beginLine+" position: "+tok.beginColumn
                     +" to line: "+tok.endLine
                     +" position: "+tok.endColumn+".");

            if(hasAlias(tok.image))
                error("#20 - Duplicate type alias '"+tok.image
                     +"' is repeated; at line: "+tok.beginLine+" position: "
                     +tok.beginColumn+" to line: "+tok.endLine+" position: "
                     +tok.endColumn+".");
            else
                addAlias(tok.image,name);
            {if (true) return name.toString();}
        break;
      case IT:
        jj_consume_token(IT);
            staticExpFlag = true;
            {if (true) return unitName.toString();}
        break;
      case MY:
        tok = jj_consume_token(MY);
            if(staticCtxFlag)
                error("#23 - Context of instance reference 'my' on line "
                     +tok.beginLine+" at position "+tok.beginColumn
                     +" is within static context.");
                {if (true) return "this.my";}
        break;
      case NIL:
        jj_consume_token(NIL);
          {if (true) return "RT.nil()";}
        break;
      case INTEGER_LITERAL:
      case FLOATING_POINT_LITERAL:
      case CHARACTER_LITERAL:
      case STRING_LITERAL:
        expr = Lit();
          {if (true) return "RT.lit("+expr+")";}
        break;
      case LPAREN:
        jj_consume_token(LPAREN);
        expr = Expr();
          {if (true) return "RT.expr("+expr+")";}
        jj_consume_token(RPAREN);
        break;
      default:
        jj_la1[43] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    throw new Error("Missing return statement in function");
  }

  static final public String Id() throws ParseException {
    Token tok = null;
    //tok = <IDENTIFIER>
        tok = IdTok();
        {if (true) return tok.image;}
    throw new Error("Missing return statement in function");
  }

  static final public Token IdTok() throws ParseException {
    Token tok = null;
    tok = jj_consume_token(IDENTIFIER);
        if(tok.image.length() > MAX_ID_LEN )
        {
            error("#31 - Constraint for identifier lexeme '"+tok.image
                 +"' exceeds maximum length of "+(MAX_ID_LEN)
                 +" characters for an identifier on line: "+tok.beginLine
                 +" at position "+tok.beginColumn+".");
        }

        if(isHostKeyword(tok.image))
        {
            error("#32 - Illegal identifier lexeme used '"+tok.image
                 +"' is host language keyword on line "+tok.beginLine
                 +" at position "+tok.beginColumn+".");
        }

        {if (true) return tok;}
    throw new Error("Missing return statement in function");
  }

//NAME ::= ID ( "." ID )*
  static final public Name Name() throws ParseException {
    String id   = null;
    Name   name = new Name();
    id = Id();
      name.add(id);
    label_18:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DOT:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_18;
      }
      jj_consume_token(DOT);
      id = Id();
         name.add(id);
    }
      {if (true) return name;}
    throw new Error("Missing return statement in function");
  }

  static final public String Lit() throws ParseException {
    String result = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER_LITERAL:
    case FLOATING_POINT_LITERAL:
      result = LiteralNumber();
          {if (true) return result;}
      break;
    case CHARACTER_LITERAL:
    case STRING_LITERAL:
      result = LiteralString();
          {if (true) return result;}
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String LiteralString() throws ParseException {
    Token tok = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CHARACTER_LITERAL:
      tok = jj_consume_token(CHARACTER_LITERAL);
      {if (true) return tok.image;}
      break;
    case STRING_LITERAL:
      tok = jj_consume_token(STRING_LITERAL);
        if(tok.image.length() > MAX_LIT_STRING_LEN)
        {
            error("#30 - Constraint for literal lexeme '"+tok.image
                 +"' exceeds maximum length of "+(MAX_LIT_STRING_LEN)
                 +" characters for a string literal on line: "
                         +tok.beginLine+" at position "+tok.beginColumn+".");
        }

        {if (true) return tok.image;}
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  static final public String LiteralNumber() throws ParseException {
    Token tok = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOATING_POINT_LITERAL:
      tok = jj_consume_token(FLOATING_POINT_LITERAL);
        if(!checkRangeDbl(tok.image))
        {
                        error("#33 - Constraint of literal floating number '"+tok.image
                                 +"' value on line "+tok.beginLine
                                 +" at position "+tok.beginColumn
                                 +" exceeds range for numeric literal.");

        }
        {if (true) return tok.image;}
      break;
    case INTEGER_LITERAL:
      tok = jj_consume_token(INTEGER_LITERAL);
        if(!checkRangeLng(tok.image))
        {
                        error("#34 - Constraint of literal integral number '"+tok.image
                                 +"' value on line "+tok.beginLine
                                 +" at position "+tok.beginColumn
                                 +" exceeds range for numeric literal.");
        }
        {if (true) return tok.image;}
      break;
    default:
      jj_la1[47] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

//EXPRLIST ::= EXPR ( "," EXPR )*
  static final public String ExprList() throws ParseException {
    String expr = null;
    Code   code = new Code();
    expr = Expr();
        code.add(expr);
    label_19:
    while (true) {
      if (jj_2_26(3)) {
        ;
      } else {
        break label_19;
      }
      jj_consume_token(COMMA);
            code.add(",");
      expr = Expr();
            code.add(expr);
    }
        {if (true) return code.toString();}
    throw new Error("Missing return statement in function");
  }

//IDLIST ::= ID ( "," ID )*
  static final public String[] IdList() throws ParseException {
    StringVector list = new StringVector();
    String       id   = null;
    id = Id();
        list.add(id);
    label_20:
    while (true) {
      if (jj_2_27(2)) {
        ;
      } else {
        break label_20;
      }
      jj_consume_token(COMMA);
      id = Id();
            list.add(id);
    }
        {if (true) return list.toArray();}
    throw new Error("Missing return statement in function");
  }

  static private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  static private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  static private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  static private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  static private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  static private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  static private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  static private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  static private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  static private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  static private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  static private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  static private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  static private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  static private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  static private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  static private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  static private boolean jj_2_18(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_18(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(17, xla); }
  }

  static private boolean jj_2_19(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_19(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(18, xla); }
  }

  static private boolean jj_2_20(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_20(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(19, xla); }
  }

  static private boolean jj_2_21(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_21(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(20, xla); }
  }

  static private boolean jj_2_22(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_22(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(21, xla); }
  }

  static private boolean jj_2_23(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_23(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(22, xla); }
  }

  static private boolean jj_2_24(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_24(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(23, xla); }
  }

  static private boolean jj_2_25(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_25(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(24, xla); }
  }

  static private boolean jj_2_26(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_26(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(25, xla); }
  }

  static private boolean jj_2_27(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_27(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(26, xla); }
  }

  static private boolean jj_3_8() {
    if (jj_3R_27()) return true;
    return false;
  }

  static private boolean jj_3R_125() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_138()) return true;
    }
    return false;
  }

  static private boolean jj_3R_92() {
    if (jj_scan_token(ISGLOB)) return true;
    return false;
  }

  static private boolean jj_3R_101() {
    if (jj_scan_token(LT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_125()) jj_scanpos = xsp;
    if (jj_scan_token(GT)) return true;
    return false;
  }

  static private boolean jj_3R_91() {
    if (jj_scan_token(SIZEOF)) return true;
    return false;
  }

  static private boolean jj_3R_90() {
    if (jj_scan_token(REM)) return true;
    return false;
  }

  static private boolean jj_3R_89() {
    if (jj_scan_token(DOLLAR)) return true;
    return false;
  }

  static private boolean jj_3R_88() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  static private boolean jj_3R_87() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  static private boolean jj_3R_76() {
    if (jj_3R_101()) return true;
    return false;
  }

  static private boolean jj_3R_86() {
    if (jj_scan_token(TILDE)) return true;
    return false;
  }

  static private boolean jj_3R_119() {
    if (jj_scan_token(AT)) return true;
    if (jj_3R_57()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_24()) return true;
    return false;
  }

  static private boolean jj_3_7() {
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_70() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_85()) {
    jj_scanpos = xsp;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) {
    jj_scanpos = xsp;
    if (jj_3R_89()) {
    jj_scanpos = xsp;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_85() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  static private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) jj_scanpos = xsp;
    if (jj_3R_59()) return true;
    return false;
  }

  static private boolean jj_3R_60() {
    if (jj_scan_token(ASSIGN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_7()) {
    jj_scanpos = xsp;
    if (jj_3R_76()) return true;
    }
    return false;
  }

  static private boolean jj_3R_50() {
    if (jj_scan_token(POW)) return true;
    return false;
  }

  static private boolean jj_3R_49() {
    if (jj_scan_token(SLASH)) return true;
    return false;
  }

  static private boolean jj_3R_22() {
    if (jj_3R_59()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_60()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_48() {
    if (jj_scan_token(REM)) return true;
    return false;
  }

  static private boolean jj_3R_47() {
    if (jj_scan_token(STAR)) return true;
    return false;
  }

  static private boolean jj_3R_83() {
    if (jj_scan_token(IF)) return true;
    if (jj_3R_21()) return true;
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  static private boolean jj_3_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) {
    jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    }
    }
    }
    if (jj_3R_51()) return true;
    return false;
  }

  static private boolean jj_3_25() {
    if (jj_3R_24()) return true;
    return false;
  }

  static private boolean jj_3R_100() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_25()) {
    jj_scanpos = xsp;
    if (jj_3R_119()) {
    jj_scanpos = xsp;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) {
    jj_scanpos = xsp;
    if (jj_3R_122()) {
    jj_scanpos = xsp;
    if (jj_3R_123()) {
    jj_scanpos = xsp;
    if (jj_3R_124()) return true;
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_46() {
    if (jj_3R_51()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_18()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_45() {
    if (jj_scan_token(MINUS)) return true;
    return false;
  }

  static private boolean jj_3R_44() {
    if (jj_scan_token(PLUS)) return true;
    return false;
  }

  static private boolean jj_3_6() {
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3_24() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_56()) return true;
    return false;
  }

  static private boolean jj_3_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) return true;
    }
    if (jj_3R_46()) return true;
    return false;
  }

  static private boolean jj_3R_43() {
    if (jj_3R_46()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_17()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_137() {
    if (jj_scan_token(BANG)) return true;
    return false;
  }

  static private boolean jj_3R_42() {
    if (jj_scan_token(RSHIFT)) return true;
    return false;
  }

  static private boolean jj_3R_41() {
    if (jj_scan_token(LSHIFT)) return true;
    return false;
  }

  static private boolean jj_3R_77() {
    if (jj_scan_token(REM)) return true;
    if (jj_3R_24()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  static private boolean jj_3_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) return true;
    }
    if (jj_3R_43()) return true;
    return false;
  }

  static private boolean jj_3R_40() {
    if (jj_3R_43()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_16()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_126() {
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3_2() {
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_39() {
    if (jj_scan_token(GE)) return true;
    return false;
  }

  static private boolean jj_3R_71() {
    if (jj_scan_token(TIC)) return true;
    if (jj_3R_58()) return true;
    return false;
  }

  static private boolean jj_3R_38() {
    if (jj_scan_token(LE)) return true;
    return false;
  }

  static private boolean jj_3R_26() {
    if (jj_scan_token(COLON)) return true;
    return false;
  }

  static private boolean jj_3R_37() {
    if (jj_scan_token(GT)) return true;
    return false;
  }

  static private boolean jj_3R_36() {
    if (jj_scan_token(LT)) return true;
    return false;
  }

  static private boolean jj_3R_135() {
    if (jj_scan_token(TRUE)) return true;
    return false;
  }

  static private boolean jj_3_15() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) {
    jj_scanpos = xsp;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) return true;
    }
    }
    }
    if (jj_3R_40()) return true;
    return false;
  }

  static private boolean jj_3R_25() {
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  static private boolean jj_3R_35() {
    if (jj_3R_40()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_15()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_34() {
    if (jj_scan_token(NE)) return true;
    return false;
  }

  static private boolean jj_3R_33() {
    if (jj_scan_token(EQ)) return true;
    return false;
  }

  static private boolean jj_3_23() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_108() {
    if (jj_scan_token(DONE)) return true;
    return false;
  }

  static private boolean jj_3R_134() {
    if (jj_scan_token(SCAN)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_23()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3_5() {
    if (jj_3R_24()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_25()) {
    jj_scanpos = xsp;
    if (jj_3R_26()) return true;
    }
    return false;
  }

  static private boolean jj_3R_102() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_126()) return true;
    }
    return false;
  }

  static private boolean jj_3_14() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_33()) {
    jj_scanpos = xsp;
    if (jj_3R_34()) return true;
    }
    if (jj_3R_35()) return true;
    return false;
  }

  static private boolean jj_3R_32() {
    if (jj_3R_35()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_14()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_1() {
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_107() {
    if (jj_scan_token(ASSIGN)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_81() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_107()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    }
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3_13() {
    if (jj_scan_token(BIT_AND)) return true;
    if (jj_3R_32()) return true;
    return false;
  }

  static private boolean jj_3R_139() {
    if (jj_3R_24()) return true;
    return false;
  }

  static private boolean jj_3R_31() {
    if (jj_3R_32()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_13()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_78() {
    if (jj_scan_token(DO)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_102()) jj_scanpos = xsp;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_103()) return true;
    return false;
  }

  static private boolean jj_3_12() {
    if (jj_scan_token(XOR)) return true;
    if (jj_3R_31()) return true;
    return false;
  }

  static private boolean jj_3R_30() {
    if (jj_3R_31()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_12()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_4() {
    if (jj_3R_23()) return true;
    return false;
  }

  static private boolean jj_3_27() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_58()) return true;
    return false;
  }

  static private boolean jj_3_11() {
    if (jj_scan_token(BIT_OR)) return true;
    if (jj_3R_30()) return true;
    return false;
  }

  static private boolean jj_3R_29() {
    if (jj_3R_30()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_11()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_103() {
    Token xsp;
    if (jj_3_4()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_4()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_109() {
    if (jj_3R_21()) return true;
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  static private boolean jj_3_22() {
    if (jj_3R_57()) return true;
    if (jj_scan_token(ASSIGN)) return true;
    return false;
  }

  static private boolean jj_3R_133() {
    if (jj_scan_token(NEW)) return true;
    if (jj_scan_token(COLON)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_22()) {
    jj_scanpos = xsp;
    if (jj_3R_139()) return true;
    }
    return false;
  }

  static private boolean jj_3_10() {
    if (jj_scan_token(AND)) return true;
    if (jj_3R_29()) return true;
    return false;
  }

  static private boolean jj_3R_82() {
    if (jj_scan_token(SNAP)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_109()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_68() {
    if (jj_3R_84()) return true;
    return false;
  }

  static private boolean jj_3R_28() {
    if (jj_3R_29()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_10()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3_26() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_67() {
    if (jj_3R_83()) return true;
    return false;
  }

  static private boolean jj_3R_66() {
    if (jj_3R_82()) return true;
    return false;
  }

  static private boolean jj_3R_56() {
    if (jj_3R_21()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_26()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_65() {
    if (jj_3R_81()) return true;
    return false;
  }

  static private boolean jj_3R_132() {
    if (jj_scan_token(FALSE)) return true;
    return false;
  }

  static private boolean jj_3R_64() {
    if (jj_3R_80()) return true;
    return false;
  }

  static private boolean jj_3R_63() {
    if (jj_3R_79()) return true;
    return false;
  }

  static private boolean jj_3_9() {
    if (jj_scan_token(OR)) return true;
    if (jj_3R_28()) return true;
    return false;
  }

  static private boolean jj_3R_21() {
    if (jj_3R_28()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_9()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_62() {
    if (jj_3R_78()) return true;
    return false;
  }

  static private boolean jj_3R_61() {
    if (jj_3R_77()) return true;
    return false;
  }

  static private boolean jj_3R_131() {
    if (jj_scan_token(EXIT)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3_3() {
    if (jj_3R_22()) return true;
    return false;
  }

  static private boolean jj_3R_23() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) {
    jj_scanpos = xsp;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) {
    jj_scanpos = xsp;
    if (jj_3R_65()) {
    jj_scanpos = xsp;
    if (jj_3R_66()) {
    jj_scanpos = xsp;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_80() {
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_146() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  static private boolean jj_3R_98() {
    if (jj_scan_token(ATCLEAR)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_97() {
    if (jj_scan_token(ATIMAGE)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_130() {
    if (jj_scan_token(EOL)) return true;
    return false;
  }

  static private boolean jj_3R_96() {
    if (jj_scan_token(ATRANGE)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_95() {
    if (jj_scan_token(HOOK)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_94() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_93() {
    if (jj_scan_token(AT)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_72() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) {
    jj_scanpos = xsp;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) {
    jj_scanpos = xsp;
    if (jj_3R_97()) {
    jj_scanpos = xsp;
    if (jj_3R_98()) return true;
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_145() {
    if (jj_scan_token(FLOATING_POINT_LITERAL)) return true;
    return false;
  }

  static private boolean jj_3R_143() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_145()) {
    jj_scanpos = xsp;
    if (jj_3R_146()) return true;
    }
    return false;
  }

  static private boolean jj_3_21() {
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_56()) return true;
    return false;
  }

  static private boolean jj_3R_129() {
    if (jj_scan_token(ECHO)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_21()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_148() {
    if (jj_scan_token(STRING_LITERAL)) return true;
    return false;
  }

  static private boolean jj_3R_128() {
    if (jj_scan_token(DIE)) return true;
    if (jj_scan_token(COLON)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3R_147() {
    if (jj_scan_token(CHARACTER_LITERAL)) return true;
    return false;
  }

  static private boolean jj_3R_144() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_147()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) return true;
    }
    return false;
  }

  static private boolean jj_3R_141() {
    if (jj_3R_144()) return true;
    return false;
  }

  static private boolean jj_3R_140() {
    if (jj_3R_143()) return true;
    return false;
  }

  static private boolean jj_3R_136() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_140()) {
    jj_scanpos = xsp;
    if (jj_3R_141()) return true;
    }
    return false;
  }

  static private boolean jj_3R_73() {
    if (jj_scan_token(DOT)) return true;
    if (jj_3R_58()) return true;
    return false;
  }

  static private boolean jj_3R_127() {
    if (jj_scan_token(ARGS)) return true;
    return false;
  }

  static private boolean jj_3R_57() {
    if (jj_3R_58()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_73()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  static private boolean jj_3R_118() {
    if (jj_3R_135()) return true;
    return false;
  }

  static private boolean jj_3R_117() {
    if (jj_3R_134()) return true;
    return false;
  }

  static private boolean jj_3R_142() {
    if (jj_scan_token(LBRACE)) return true;
    return false;
  }

  static private boolean jj_3R_116() {
    if (jj_3R_133()) return true;
    return false;
  }

  static private boolean jj_3R_115() {
    if (jj_3R_132()) return true;
    return false;
  }

  static private boolean jj_3R_106() {
    if (jj_scan_token(INTEGER_LITERAL)) return true;
    return false;
  }

  static private boolean jj_3R_114() {
    if (jj_3R_131()) return true;
    return false;
  }

  static private boolean jj_3R_113() {
    if (jj_3R_130()) return true;
    return false;
  }

  static private boolean jj_3R_112() {
    if (jj_3R_129()) return true;
    return false;
  }

  static private boolean jj_3R_111() {
    if (jj_3R_128()) return true;
    return false;
  }

  static private boolean jj_3R_105() {
    if (jj_scan_token(END)) return true;
    return false;
  }

  static private boolean jj_3R_110() {
    if (jj_3R_127()) return true;
    return false;
  }

  static private boolean jj_3R_104() {
    if (jj_scan_token(CUT)) return true;
    return false;
  }

  static private boolean jj_3R_99() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_110()) {
    jj_scanpos = xsp;
    if (jj_3R_111()) {
    jj_scanpos = xsp;
    if (jj_3R_112()) {
    jj_scanpos = xsp;
    if (jj_3R_113()) {
    jj_scanpos = xsp;
    if (jj_3R_114()) {
    jj_scanpos = xsp;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) {
    jj_scanpos = xsp;
    if (jj_3R_117()) {
    jj_scanpos = xsp;
    if (jj_3R_118()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  static private boolean jj_3R_79() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_104()) {
    jj_scanpos = xsp;
    if (jj_3R_105()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_106()) jj_scanpos = xsp;
    if (jj_scan_token(SEMICOLON)) return true;
    return false;
  }

  static private boolean jj_3R_55() {
    if (jj_scan_token(DEC)) return true;
    return false;
  }

  static private boolean jj_3R_24() {
    if (jj_scan_token(IDENTIFIER)) return true;
    return false;
  }

  static private boolean jj_3R_54() {
    if (jj_scan_token(INC)) return true;
    return false;
  }

  static private boolean jj_3R_69() {
    if (jj_scan_token(COMMA)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  static private boolean jj_3_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) return true;
    }
    return false;
  }

  static private boolean jj_3R_58() {
    if (jj_3R_24()) return true;
    return false;
  }

  static private boolean jj_3R_27() {
    if (jj_scan_token(LBRACKET)) return true;
    if (jj_3R_21()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_69()) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(RBRACKET)) return true;
    return false;
  }

  static private boolean jj_3R_53() {
    if (jj_3R_72()) return true;
    if (jj_3R_137()) return true;
    return false;
  }

  static private boolean jj_3R_52() {
    if (jj_3R_71()) return true;
    return false;
  }

  static private boolean jj_3R_124() {
    if (jj_scan_token(LPAREN)) return true;
    if (jj_3R_21()) return true;
    if (jj_scan_token(RPAREN)) return true;
    return false;
  }

  static private boolean jj_3_19() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    }
    return false;
  }

  static private boolean jj_3R_123() {
    if (jj_3R_136()) return true;
    return false;
  }

  static private boolean jj_3R_122() {
    if (jj_scan_token(NIL)) return true;
    return false;
  }

  static private boolean jj_3R_75() {
    if (jj_3R_100()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3_19()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3_20()) jj_scanpos = xsp;
    return false;
  }

  static private boolean jj_3R_74() {
    if (jj_3R_99()) return true;
    return false;
  }

  static private boolean jj_3R_121() {
    if (jj_scan_token(MY)) return true;
    return false;
  }

  static private boolean jj_3R_59() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) return true;
    }
    return false;
  }

  static private boolean jj_3R_120() {
    if (jj_scan_token(IT)) return true;
    return false;
  }

  static private boolean jj_3R_138() {
    if (jj_3R_142()) return true;
    return false;
  }

  static private boolean jj_3R_84() {
    if (jj_scan_token(TRY)) return true;
    if (jj_3R_103()) return true;
    if (jj_scan_token(ON)) return true;
    return false;
  }

  static private boolean jj_initialized_once = false;
  /** Generated Token Manager. */
  static public BozCompilerTokenManager token_source;
  static JavaCharStream jj_input_stream;
  /** Current token. */
  static public Token token;
  /** Next token. */
  static public Token jj_nt;
  static private int jj_ntk;
  static private Token jj_scanpos, jj_lastpos;
  static private int jj_la;
  static private int jj_gen;
  static final private int[] jj_la1 = new int[48];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
      jj_la1_init_2();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xc67000,0x0,0xf9180000,0xf9180000,0x8000,0x10000,0x2000,0x21000,0x0,0xf9180000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0xf9180000,0xf9000000,0x0,0x180000,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x4000000,0x28000000,0x800000,0x4000000,0x28000000,0x28000000,0x4000000,0x4000000,0x80000800,0x80000800,0x80000800,0x80000800,0x1100000,0x1800000,0xa8004e9f,0xa8004e9f,0x0,0x0,0x0,0x0,0x10,0xa8004e9f,0x1000000,0x4000000,0x4000000,0x1000000,0x10000,0x50000,0x200000,0x200000,0xc0800000,0x0,0x6000000,0x0,0x0,0x0,0x28000000,0x28000000,0xd0800000,0x0,0x80004e9f,0xd,0x800,0x80004692,0x400000,0x690,0x600,0x90,};
   }
   private static void jj_la1_init_2() {
      jj_la1_2 = new int[] {0x0,0x600,0x0,0x0,0x600,0x600,0x0,0x0,0x0,0x0,0x0,0x0,0x20000,0x0,0x320601,0x320601,0x0,0x0,0x0,0x0,0x0,0x320601,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1c00000,0x12,0xc,0xc0000,0x600,0x31800,0x320601,0x320601,0x1c00000,0x180,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
  static final private JJCalls[] jj_2_rtns = new JJCalls[27];
  static private boolean jj_rescan = false;
  static private int jj_gc = 0;

  /** Constructor with InputStream. */
  public BozCompiler(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public BozCompiler(java.io.InputStream stream, String encoding) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser.  ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new BozCompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  static public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor. */
  public BozCompiler(java.io.Reader stream) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new BozCompilerTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  static public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Constructor with generated Token Manager. */
  public BozCompiler(BozCompilerTokenManager tm) {
    if (jj_initialized_once) {
      System.out.println("ERROR: Second call to constructor of static parser. ");
      System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
      System.out.println("       during parser generation.");
      throw new Error();
    }
    jj_initialized_once = true;
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  /** Reinitialise. */
  public void ReInit(BozCompilerTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 48; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  static private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  static private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }


/** Get the next Token. */
  static final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

/** Get the specific Token. */
  static final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  static private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  static private int[] jj_expentry;
  static private int jj_kind = -1;
  static private int[] jj_lasttokens = new int[100];
  static private int jj_endpos;

  static private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      jj_entries_loop: for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext();) {
        int[] oldentry = (int[])(it.next());
        if (oldentry.length == jj_expentry.length) {
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              continue jj_entries_loop;
            }
          }
          jj_expentries.add(jj_expentry);
          break jj_entries_loop;
        }
      }
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  /** Generate ParseException. */
  static public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[89];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 48; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 89; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  /** Enable tracing. */
  static final public void enable_tracing() {
  }

  /** Disable tracing. */
  static final public void disable_tracing() {
  }

  static private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 27; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
            case 17: jj_3_18(); break;
            case 18: jj_3_19(); break;
            case 19: jj_3_20(); break;
            case 20: jj_3_21(); break;
            case 21: jj_3_22(); break;
            case 22: jj_3_23(); break;
            case 23: jj_3_24(); break;
            case 24: jj_3_25(); break;
            case 25: jj_3_26(); break;
            case 26: jj_3_27(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  static private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

     //end main

}
